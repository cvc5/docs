<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>ProofRule</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="ProofRule";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":10,"i2":9,"i3":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"> <script> window.MathJax = { 'loader': { 'load': ['[tex]/ams','[tex]/bussproofs'], }, 'tex': { 'packages': { '[+]': ['ams','bussproofs'], }, 'macros': { 'xor': '\\mathbin{xor}', 'ite': ['#1~\\mathbin{?}~#2~\\mathbin{:}~#3',3], 'inferrule': ['\\begin{prooftree}\\AxiomC{$#1$}\\UnaryInfC{$#2$}\\end{prooftree}',2], 'inferruleSC': ['\\begin{prooftree}\\AxiomC{$#1$}\\RightLabel{~#3}\\UnaryInfC{$#2$}\\end{prooftree}',3], } } } </script> <script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'> </script> </div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum.constant.summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum.constant.detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.github.cvc5</a></div>
<h2 title="Enum ProofRule" class="title">Enum ProofRule</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>java.lang.Enum&lt;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>&gt;</li>
<li>
<ul class="inheritance">
<li>io.github.cvc5.ProofRule</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.io.Serializable</code>, <code>java.lang.Comparable&lt;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>&gt;</code></dd>
</dl>
<hr>
<pre>public enum <span class="typeNameLabel">ProofRule</span>
extends java.lang.Enum&lt;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>&gt;</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ENUM CONSTANT SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="enum.constant.summary">
<!--   -->
</a>
<h3>Enum Constant Summary</h3>
<table class="memberSummary">
<caption><span>Enum Constants</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Enum Constant</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ACI_NORM">ACI_NORM</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; associative/commutative/idempotency/identity normalization
 
 \[
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{expr::isACNorm(t, s)} = \top\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ALETHE_RULE">ALETHE_RULE</a></span></code></th>
<td class="colLast">
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ALPHA_EQUIV">ALPHA_EQUIV</a></span></code></th>
<td class="colLast">
<div class="block">Quantifiers &ndash; Alpha equivalence
 
 \[
 
   \inferruleSC{-\mid F, (y_1 \ldots y_n), (z_1,\dots, z_n)}
   {F = F\{y_1\mapsto z_1,\dots,y_n\mapsto z_n\}}
   {if $y_1,\dots,y_n, z_1,\dots,z_n$ are unique bound variables}
 \]
 Notice that this rule is correct only when \(z_1,\dots,z_n\) are not
 contained in \(FV(F) \setminus \{ y_1,\dots, y_n \}\), where
 \(FV(\varphi)\) are the free variables of \(\varphi\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#AND_ELIM">AND_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; And elimination
 
 \[
   \inferrule{(F_1 \land \dots \land F_n) \mid i}{F_i}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#AND_INTRO">AND_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; And introduction
 
 \[
   \inferrule{F_1 \dots F_n \mid -}{(F_1 \land \dots \land F_n)}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ANNOTATION">ANNOTATION</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Annotation
 
 \[
   \inferrule{F \mid a_1 \dots a_n}{F}
 \]
 The terms \(a_1 \dots a_n\) can be anything used to annotate the proof
 node, one example is where \(a_1\) is a theory.InferenceId.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_MULT_NEG">ARITH_MULT_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Multiplication with negative factor
 
 \[
   \inferrule{- \mid m, l \diamond r}{(m &lt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond_{inv} m \cdot r}
 \]
 where \(\diamond\) is a relation symbol and \(\diamond_{inv}\) the
 inverted relation symbol.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_MULT_POS">ARITH_MULT_POS</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Multiplication with positive factor
 
 \[
   \inferrule{- \mid m, l \diamond r}{(m &gt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond m \cdot r}
 \]
 where \(\diamond\) is a relation symbol.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_MULT_SIGN">ARITH_MULT_SIGN</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Sign inference
 
 \[
   \inferrule{- \mid f_1 \dots f_k, m}{(f_1 \land \dots \land f_k) \rightarrow m \diamond 0}
 \]
 where \(f_1 \dots f_k\) are variables compared to zero (less, greater
 or not equal), \(m\) is a monomial from these variables and
 \(\diamond\) is the comparison (less or equal) that results from the
 signs of the variables.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_MULT_TANGENT">ARITH_MULT_TANGENT</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Multiplication tangent plane
 
 \[
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \leq tplane) \leftrightarrow ((x \leq a \land y \geq b) \lor (x \geq a \land y \leq b))}{if $\sigma = -1$}
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \geq tplane) \leftrightarrow ((x \leq a \land y \leq b) \lor (x \geq a \land y \geq b))}{if $\sigma = 1$}
 \]
 where \(x,y\) are real terms (variables or extended terms),
 \(t = x \cdot y\), \(a,b\) are real
 constants, \(\sigma \in \{ 1, -1\}\) and \(tplane := b \cdot x + a \cdot y - a \cdot b\) is the tangent plane of \(x \cdot y\) at \((a,b)\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_OP_ELIM_AXIOM">ARITH_OP_ELIM_AXIOM</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Operator elimination
 
 \[
   \inferrule{- \mid t}{\texttt{arith::OperatorElim::getAxiomFor(t)}}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_POLY_NORM">ARITH_POLY_NORM</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Polynomial normalization
 
 \[
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_POLY_NORM_REL">ARITH_POLY_NORM_REL</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Polynomial normalization for relations
 
 ..</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_SUM_UB">ARITH_SUM_UB</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Sum upper bounds
 
 \[
   \inferrule{P_1 \dots P_n \mid -}{L \diamond R}
 \]
 where \(P_i\) has the form \(L_i \diamond_i R_i\) and
 \(\diamond_i \in \{&lt;, \leq, =\}\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_APPROX_ABOVE_NEG">ARITH_TRANS_EXP_APPROX_ABOVE_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for
 negative values
 
 \[
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_APPROX_ABOVE_POS">ARITH_TRANS_EXP_APPROX_ABOVE_POS</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for
 positive values
 
 \[
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant-pos}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_APPROX_BELOW">ARITH_TRANS_EXP_APPROX_BELOW</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from below
 
 \[
   \inferrule{- \mid d,c,t}{t \geq c \rightarrow exp(t) \geq \texttt{maclaurin}(\exp, d, c)}
 \]
 where \(d\) is an odd positive number, \(t\) an arithmetic term and
 \(\texttt{maclaurin}(\exp, d, c)\) is the \(d\)'th taylor
 polynomial at zero (also called the Maclaurin series) of the exponential
 function evaluated at \(c\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_NEG">ARITH_TRANS_EXP_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at negative values
 
 \[
   \inferrule{- \mid t}{(t &lt; 0) \leftrightarrow (\exp(t) &lt; 1)}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_POSITIVITY">ARITH_TRANS_EXP_POSITIVITY</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is always positive
 
 \[
   \inferrule{- \mid t}{\exp(t) &gt; 0}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_SUPER_LIN">ARITH_TRANS_EXP_SUPER_LIN</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp grows super-linearly for positive
 values
 
 \[
   \inferrule{- \mid t}{t \leq 0 \lor \exp(t) &gt; t+1}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_EXP_ZERO">ARITH_TRANS_EXP_ZERO</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at zero
 
 \[
   \inferrule{- \mid t}{(t=0) \leftrightarrow (\exp(t) = 1)}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_PI">ARITH_TRANS_PI</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Assert bounds on Pi
 
 \[
   \inferrule{- \mid l, u}{\texttt{real.pi} \geq l \land \texttt{real.pi}
   \leq u}
 \]
 where \(l,u\) are valid lower and upper bounds on \(\pi\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_APPROX_ABOVE_NEG">ARITH_TRANS_SINE_APPROX_ABOVE_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for
 negative values
 
 \[
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_APPROX_ABOVE_POS">ARITH_TRANS_SINE_APPROX_ABOVE_POS</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for
 positive values
 
 \[
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{upper}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_APPROX_BELOW_NEG">ARITH_TRANS_SINE_APPROX_BELOW_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for
 negative values
 
 \[
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{lower}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_APPROX_BELOW_POS">ARITH_TRANS_SINE_APPROX_BELOW_POS</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for
 positive values
 
 \[
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_BOUNDS">ARITH_TRANS_SINE_BOUNDS</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is always between -1 and 1
 
 \[
   \inferrule{- \mid t}{\sin(t) \leq 1 \land \sin(t) \geq -1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_SHIFT">ARITH_TRANS_SINE_SHIFT</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is shifted to -pi...pi
 
 \[
   \inferrule{- \mid x}{-\pi \leq y \leq \pi \land \sin(y) = \sin(x)
   \land (\ite{-\pi \leq x \leq \pi}{x = y}{x = y + 2 \pi s})}
 \]
 where \(x\) is the argument to sine, \(y\) is a new real skolem
 that is \(x\) shifted into \(-\pi \dots \pi\) and \(s\) is a
 new integer skolem that is the number of phases \(y\) is shifted.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_SYMMETRY">ARITH_TRANS_SINE_SYMMETRY</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is symmetric with respect to
 negation of the argument
 
 \[
   \inferrule{- \mid t}{\sin(t) - \sin(-t) = 0}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_TANGENT_PI">ARITH_TRANS_SINE_TANGENT_PI</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangents at -pi
 and pi
 
 ..</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRANS_SINE_TANGENT_ZERO">ARITH_TRANS_SINE_TANGENT_ZERO</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangent at zero
 
 ..</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARITH_TRICHOTOMY">ARITH_TRICHOTOMY</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Trichotomy of the reals
 
 \[
   \inferrule{A, B \mid -}{C}
 \]
 where \(\neg A, \neg B, C\) are \(x &lt; c, x = c, x &gt; c\) in some order.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARRAYS_EXT">ARRAYS_EXT</a></span></code></th>
<td class="colLast">
<div class="block">Arrays &ndash; Arrays extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{select}(a,k)\neq\mathit{select}(b,k)}
 \]
 where \(k\) is the \(\texttt{ARRAY_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARRAYS_READ_OVER_WRITE">ARRAYS_READ_OVER_WRITE</a></span></code></th>
<td class="colLast">
<div class="block">Arrays &ndash; Read over write
 
 \[
 
   \inferrule{i_1 \neq i_2\mid \mathit{select}(\mathit{store}(a,i_1,e),i_2)}
   {\mathit{select}(\mathit{store}(a,i_1,e),i_2) = \mathit{select}(a,i_2)}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARRAYS_READ_OVER_WRITE_1">ARRAYS_READ_OVER_WRITE_1</a></span></code></th>
<td class="colLast">
<div class="block">Arrays &ndash; Read over write 1
 
 \[
 
   \inferrule{-\mid \mathit{select}(\mathit{store}(a,i,e),i)}
   {\mathit{select}(\mathit{store}(a,i,e),i)=e}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ARRAYS_READ_OVER_WRITE_CONTRA">ARRAYS_READ_OVER_WRITE_CONTRA</a></span></code></th>
<td class="colLast">
<div class="block">Arrays &ndash; Read over write, contrapositive
 
 \[
 
   \inferrule{\mathit{select}(\mathit{store}(a,i_2,e),i_1) \neq
   \mathit{select}(a,i_1)\mid -}{i_1=i_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ASSUME">ASSUME</a></span></code></th>
<td class="colLast">
<div class="block">Assumption (a leaf)
 
 \[
 
   \inferrule{- \mid F}{F}
 \]
 This rule has special status, in that an application of assume is an
 open leaf in a proof that is not (yet) justified.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#BV_BITBLAST_STEP">BV_BITBLAST_STEP</a></span></code></th>
<td class="colLast">
<div class="block">Bit-vectors &ndash; Bitblast bit-vector constant, variable, and terms
 
 For constant and variables:
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 For terms:
 
 \[
 
   \inferrule{-\mid k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n))}
   {k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n)) =
   \texttt{bitblast}(t)}
 \]
 where \(t\) is \(k(t_1,\dots,t_n)\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#BV_EAGER_ATOM">BV_EAGER_ATOM</a></span></code></th>
<td class="colLast">
<div class="block">Bit-vectors &ndash; Bit-vector eager atom
 
 \[
 
   \inferrule{-\mid F}{F = F[0]}
 \]
 where \(F\) is of kind <code>BITVECTOR_EAGER_ATOM</code>.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CHAIN_RESOLUTION">CHAIN_RESOLUTION</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; N-ary Resolution
 
 \[
   \inferrule{C_1 \dots C_n \mid (pol_1 \dots pol_{n-1}), (L_1 \dots L_{n-1})}{C}
 \]
 where
 
 
 let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined above
 
 let \(C_1 \diamond_{L,pol} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined above
 
 let \(C_1' = C_1\),
 
 for each \(i &gt; 1\), let \(C_i' = C_{i-1} \diamond_{L_{i-1}, pol_{i-1}} C_i'\)
 
 
 Note the list of polarities and pivots are provided as s-expressions.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_AND_NEG">CNF_AND_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; And Negative
 
 \[
   \inferrule{- \mid (F_1 \land \dots \land F_n)}{(F_1 \land \dots \land
   F_n) \lor \neg F_1 \lor \dots \lor \neg F_n}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_AND_POS">CNF_AND_POS</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; And Positive
 
 \[
   \inferrule{- \mid (F_1 \land \dots \land F_n), i}{\neg (F_1 \land \dots
   \land F_n) \lor F_i}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_EQUIV_NEG1">CNF_EQUIV_NEG1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 1
 
 \[
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_EQUIV_NEG2">CNF_EQUIV_NEG2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 2
 
 \[
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor \neg F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_EQUIV_POS1">CNF_EQUIV_POS1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 1
 
 \[
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor \neg F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_EQUIV_POS2">CNF_EQUIV_POS2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 2
 
 \[
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_IMPLIES_NEG1">CNF_IMPLIES_NEG1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 1
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor F_1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_IMPLIES_NEG2">CNF_IMPLIES_NEG2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 2
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_IMPLIES_POS">CNF_IMPLIES_POS</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Implies Positive
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{\neg(F_1 \rightarrow F_2) \lor \neg F_1
   \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_NEG1">CNF_ITE_NEG1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 1
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg C
   \lor \neg F_1}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_NEG2">CNF_ITE_NEG2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 2
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor C \lor
   \neg F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_NEG3">CNF_ITE_NEG3</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 3
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg F_1
   \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_POS1">CNF_ITE_POS1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 1
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor \neg
   C \lor F_1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_POS2">CNF_ITE_POS2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 2
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor C
   \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_ITE_POS3">CNF_ITE_POS3</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 3
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor F_1
   \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_OR_NEG">CNF_OR_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Or Negative
 
 \[
   \inferrule{- \mid (F_1 \lor \dots \lor F_n), i}{(F_1 \lor \dots \lor F_n)
   \lor \neg F_i}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_OR_POS">CNF_OR_POS</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; Or Positive
 
 \[
   \inferrule{- \mid (F_1 \lor \dots \lor F_n)}{\neg(F_1 \lor \dots \lor
   F_n) \lor F_1 \lor \dots \lor F_n}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_XOR_NEG1">CNF_XOR_NEG1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 1
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor \neg F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_XOR_NEG2">CNF_XOR_NEG2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 2
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_XOR_POS1">CNF_XOR_POS1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 1
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CNF_XOR_POS2">CNF_XOR_POS2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 2
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor \neg F_1 \lor
   \neg F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_CONFLICT">CONCAT_CONFLICT</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation conflict
 
 \[
 
   \inferrule{(c_1\cdot t) = (c_2 \cdot s)\mid b}{\bot}
 \]
 where \(b\) indicates if the direction is reversed, \(c_1,\,c_2\)
 are constants such that \(\texttt{Word::splitConstant}(c_1,c_2,
 \mathit{index},b)\) is null, in other words, neither is a prefix of the
 other.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_CONFLICT_DEQ">CONCAT_CONFLICT_DEQ</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation conflict for disequal characters
 
 \[
 
   \inferrule{(t_1\cdot t) = (s_1 \cdot s), t_1 \neq s_1 \mid b}{\bot}
 \]
 where \(t_1\) and \(s_1\) are constants of length one, or otherwise one side
 of the equality is the empty sequence and \(t_1\) or \(s_1\) corresponding to
 that side is the empty sequence.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_CPROP">CONCAT_CPROP</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation constant propagation
 
 \[
 
   \inferrule{(t_1\cdot w_1\cdot t_2) = (w_2 \cdot s),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = t_3\cdot r)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{pre}(w_2,p)\), \(p\) is
 \(\texttt{Word::overlap}(\mathit{suf}(w_2,1), w_1)\), and \(r\) is
 the purification skolem for
 \(\mathit{suf}(t_1,\mathit{len}(w_3))\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_CSPLIT">CONCAT_CSPLIT</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split for constants
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (c \cdot s_2),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = c\cdot r)}
 \]
 where \(r\) is the purification skolem for \(\mathit{suf}(t_1,1)\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_EQ">CONCAT_EQ</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation equality
 
 \[
 
   \inferrule{(t_1\cdot\ldots \cdot t_n \cdot t) = (t_1 \cdot\ldots
   \cdot t_n\cdot s)\mid b}{t = s}
 \]
 where \(\cdot\) stands for string concatenation and \(b\) indicates
 if the direction is reversed.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_LPROP">CONCAT_LPROP</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation length propagation
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_1) &gt; \mathit{len}(s_1)\mid \bot}{(t_1 = s_1\cdot r)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_SPLIT">CONCAT_SPLIT</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split
 
 \[
 
   \inferruleSC{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_1) \neq \mathit{len}(s_1)\mid b}{((t_1 = s_1\cdot r)
   \vee (s_1 = t_1\cdot r)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}{if $b=\bot$}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\)
 and \(\epsilon\) is the empty string (or sequence).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONCAT_UNIFY">CONCAT_UNIFY</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation unification
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\, \mathit{len}(t_1) =
   \mathit{len}(s_1)\mid \bot}{t_1 = s_1}
 \]
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\, \mathit{len}(t_2) =
   \mathit{len}(s_2)\mid \top}{t_2 = s_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONG">CONG</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid k, f?}{k(f?, t_1,\dots, t_n) =
   k(f?, s_1,\dots, s_n)}
 \]
 where \(k\) is the application kind.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#CONTRA">CONTRA</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Contradiction
 
 \[
   \inferrule{F, \neg F \mid -}{\bot}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DRAT_REFUTATION">DRAT_REFUTATION</a></span></code></th>
<td class="colLast">
<div class="block">DRAT Refutation
 
 \[
   \inferrule{F_1 \dots F_n \mid D, P}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the clauses in the
 DIMACS file given by filename `D` and `P` is a filename of a file storing
 a DRAT proof.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DSL_REWRITE">DSL_REWRITE</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; DSL rewrite
 
 \[
   \inferrule{F_1 \dots F_n \mid id t_1 \dots t_n}{F}
 \]
 where `id` is a ProofRewriteRule whose definition in the
 RARE DSL is \(\forall x_1 \dots x_n.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DT_CLASH">DT_CLASH</a></span></code></th>
<td class="colLast">
<div class="block">Datatypes &ndash; Clash
 
 \[
 
   \inferruleSC{\mathit{is}_{C_i}(t), \mathit{is}_{C_j}(t)\mid -}{\bot}
   {if $i\neq j$}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DT_SPLIT">DT_SPLIT</a></span></code></th>
<td class="colLast">
<div class="block">Datatypes &ndash; Split
 
 \[
 
   \inferrule{-\mid t}{\mathit{is}_{C_1}(t)\vee\cdots\vee\mathit{is}_{C_n}(t)}
 \]
 where \(C_1,\dots,C_n\) are all the constructors of the type of \(t\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#DT_UNIF">DT_UNIF</a></span></code></th>
<td class="colLast">
<div class="block">Datatypes &ndash; Unification
 
 \[
 
   \inferrule{C(t_1,\dots,t_n)= C(s_1,\dots,s_n)\mid i}{t_1 = s_i}
 \]
 where \(C\) is a constructor.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ENCODE_EQ_INTRO">ENCODE_EQ_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Encode equality introduction
 
 \[
   \inferrule{- \mid t}{t=t'}
 \]
 where \(t\) and \(t'\) are equivalent up to their encoding in an
 external proof format.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#EQ_RESOLVE">EQ_RESOLVE</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Equality resolution
 
 \[
   \inferrule{F_1, (F_1 = F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 EQUIV_ELIM1 &lt;cvc5.<a href="#EQUIV_ELIM1"><code>EQUIV_ELIM1</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#EQUIV_ELIM1">EQUIV_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Equivalence elimination version 1
 
 \[
   \inferrule{F_1 = F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#EQUIV_ELIM2">EQUIV_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Equivalence elimination version 2
 
 \[
   \inferrule{F_1 = F_2 \mid -}{F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#EVALUATE">EVALUATE</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Evaluate
 
 \[
   \inferrule{- \mid t}{t = \texttt{evaluate}(t)}
 \]
 where \(\texttt{evaluate}\) is implemented by calling the method
 \(\texttt{Evalutor::evaluate}\) in :cvc5src:`theory/evaluator.h` with an
 empty substitution.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#FACTORING">FACTORING</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Factoring
 
 \[
   \inferrule{C_1 \mid -}{C_2}
 \]
 where \(C_2\) is the clause \(C_1\), but every occurrence of a literal
 after its first occurrence is omitted.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#FALSE_ELIM">FALSE_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; False elim
 
 \[
 
   \inferrule{F=\bot\mid -}{\neg F}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#FALSE_INTRO">FALSE_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; False intro
 
 \[
 
   \inferrule{\neg F\mid -}{F = \bot}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#HO_APP_ENCODE">HO_APP_ENCODE</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Higher-order application encoding
 
 \[
 
   \inferrule{-\mid t}{t=t'}
 \]
 where `t'` is the higher-order application that is equivalent to `t`,
 as implemented by <code>uf.TheoryUfRewriter.getHoApplyForApplyUf</code>.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#HO_CONG">HO_CONG</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Higher-order congruence
 
 \[
 
   \inferrule{f=g, t_1=s_1,\dots,t_n=s_n\mid k}{k(f, t_1,\dots, t_n) =
   k(g, s_1,\dots, s_n)}
 \]
 Notice that this rule is only used when the application kind \(k\) is
 either `cvc5.Kind.APPLY_UF` or `cvc5.Kind.HO_APPLY`.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#IMPLIES_ELIM">IMPLIES_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Implication elimination
 
 \[
   \inferrule{F_1 \rightarrow F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#INSTANTIATE">INSTANTIATE</a></span></code></th>
<td class="colLast">
<div class="block">Quantifiers &ndash; Instantiation
 
 \[
 
   \inferrule{\forall x_1\dots x_n.\&gt; F\mid (t_1 \dots t_n), (id\, (t)?)?}
   {F\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}}
 \]
 The list of terms to instantiate \((t_1 \dots t_n)\) is provided as
 an s-expression as the first argument.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#INT_TIGHT_LB">INT_TIGHT_LB</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Tighten strict integer lower bounds
 
 \[
   \inferrule{i &gt; c \mid -}{i \geq \lceil c \rceil}
 \]
 where \(i\) has integer type.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#INT_TIGHT_UB">INT_TIGHT_UB</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Tighten strict integer upper bounds
 
 \[
   \inferrule{i &lt; c \mid -}{i \leq \lfloor c \rfloor}
 \]
 where \(i\) has integer type.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ITE_ELIM1">ITE_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; ITE elimination version 1
 
 \[
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor F_1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ITE_ELIM2">ITE_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; ITE elimination version 2
 
 \[
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{C \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#ITE_EQ">ITE_EQ</a></span></code></th>
<td class="colLast">
<div class="block">Processing rules &ndash; If-then-else equivalence
 
 \[
   \inferrule{- \mid \ite{C}{t_1}{t_2}}{\ite{C}{((\ite{C}{t_1}{t_2}) = t_1)}{((\ite{C}{t_1}{t_2}) = t_2)}}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#LFSC_RULE">LFSC_RULE</a></span></code></th>
<td class="colLast">
<div class="block">External &ndash; LFSC
 
 Place holder for LFSC rules.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_ARITH_SCALE_SUM_UB">MACRO_ARITH_SCALE_SUM_UB</a></span></code></th>
<td class="colLast">
<div class="block">Arithmetic &ndash; Adding inequalities
 
 An arithmetic literal is a term of the form \(p \diamond c\) where
 \(\diamond \in \{ &lt;, \leq, =, \geq, &gt; \}\), \(p\) a
 polynomial and \(c\) a rational constant.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_BV_BITBLAST">MACRO_BV_BITBLAST</a></span></code></th>
<td class="colLast">
<div class="block">Bit-vectors &ndash; (Macro) Bitblast
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 where \(\texttt{bitblast}\) represents the result of the bit-blasted term as
 a bit-vector consisting of the output bits of the bit-blasted circuit
 representation of the term.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_RE_ELIM">MACRO_RE_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Regular expressions &ndash; Macro elimination
 
 \[
 
   \inferrule{-\mid F,b}{F = F'}
 \]
 where \(F'\) is the result of eliminating regular expressions from
 \(F\) using the routine
 \(\texttt{strings::RegExpElimination::eliminate}(F, b)\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_RESOLUTION">MACRO_RESOLUTION</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering
 
 \[
   \inferrule{C_1 \dots C_n \mid C, pol_1,L_1 \dots pol_{n-1},L_{n-1}}{C}
 \]
 where
 
 
 let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 
 let \(C_1 \diamond_{L,\mathit{pol}} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 
 let \(C_1'\) be equal, in its set representation, to \(C_1\),
 
 for each \(i &gt; 1\), let \(C_i'\) be equal, in its set
   representation, to \(C_{i-1} \diamond_{L_{i-1},\mathit{pol}_{i-1}}
   C_i'\)
 
 
 The result of the chain resolution is \(C\), which is equal, in its set
 representation, to \(C_n'\)</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_RESOLUTION_TRUST">MACRO_RESOLUTION_TRUST</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering unchecked
 
 Same as
 MACRO_RESOLUTION &lt;cvc5.<a href="#MACRO_RESOLUTION"><code>MACRO_RESOLUTION</code></a>&gt;, but
 not checked by the internal proof checker.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_REWRITE">MACRO_REWRITE</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Rewrite
 
 \[
   \inferrule{- \mid t, idr}{t = \texttt{rewrite}_{idr}(t)}
 \]
 where \(idr\) is a MethodId identifier, which determines the kind of
 rewriter to apply, e.g.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_SR_EQ_INTRO">MACRO_SR_EQ_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Substitution + Rewriting equality introduction
 
 In this rule, we provide a term \(t\) and conclude that it is equal to
 its rewritten form under a (proven) substitution.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_SR_PRED_ELIM">MACRO_SR_PRED_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
   \inferrule{F, F_1 \dots F_n \mid (ids (ida
   (idr)?)?)?}{\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
   \cdots \circ \sigma_{ids, ida}(F_1))}
 \]
 where \(ids\) and \(idr\) are method identifiers.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_SR_PRED_INTRO">MACRO_SR_PRED_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate introduction
 
 In this rule, we provide a formula \(F\) and conclude it, under the
 condition that it rewrites to true under a proven substitution.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_SR_PRED_TRANSFORM">MACRO_SR_PRED_TRANSFORM</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
   \inferrule{F, F_1 \dots F_n \mid G, (ids (ida (idr)?)?)?}{G}
 \]
 where
 
 \[
   \texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ\cdots \circ \sigma_{ids, ida}(F_1)) =\\ \texttt{rewrite}_{idr}(G \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ \sigma_{ids, ida}(F_1))
 \]
 More generally, this rule also holds when:
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \texttt{Rewriter::rewrite}(\texttt{toOriginal}(G'))\)
 where \(F'\) and \(G'\) are the result of each side of the equation
 above.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MACRO_STRING_INFERENCE">MACRO_STRING_INFERENCE</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; (Macro) String inference
 
 \[
 
   \inferrule{?\mid F,\mathit{id},\mathit{isRev},\mathit{exp}}{F}
 \]
 used to bookkeep an inference that has not yet been converted via
 \(\texttt{strings::InferProofCons::convert}\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#MODUS_PONENS">MODUS_PONENS</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Modus Ponens
 
 \[
   \inferrule{F_1, (F_1 \rightarrow F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 IMPLIES_ELIM &lt;cvc5.<a href="#IMPLIES_ELIM"><code>IMPLIES_ELIM</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NARY_CONG">NARY_CONG</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; N-ary Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid k}{k(t_1,\dots, t_n) =
   k(s_1,\dots, s_n)}
 \]
 where \(k\) is the application kind.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_AND">NOT_AND</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; De Morgan &ndash; Not And
 
 \[
   \inferrule{\neg(F_1 \land \dots \land F_n) \mid -}{\neg F_1 \lor \dots
   \lor \neg F_n}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_EQUIV_ELIM1">NOT_EQUIV_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not Equivalence elimination version 1
 
 \[
   \inferrule{F_1 \neq F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_EQUIV_ELIM2">NOT_EQUIV_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not Equivalence elimination version 2
 
 \[
   \inferrule{F_1 \neq F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_IMPLIES_ELIM1">NOT_IMPLIES_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not Implication elimination version 1
 
 \[
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{F_1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_IMPLIES_ELIM2">NOT_IMPLIES_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not Implication elimination version 2
 
 \[
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{\neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_ITE_ELIM1">NOT_ITE_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not ITE elimination version 1
 
 \[
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor \neg F_1}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_ITE_ELIM2">NOT_ITE_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not ITE elimination version 2
 
 \[
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{C \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_NOT_ELIM">NOT_NOT_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Double negation elimination
 
 \[
   \inferrule{\neg (\neg F) \mid -}{F}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_OR_ELIM">NOT_OR_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not Or elimination
 
 \[
   \inferrule{\neg(F_1 \lor \dots \lor F_n) \mid i}{\neg F_i}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_XOR_ELIM1">NOT_XOR_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not XOR elimination version 1
 
 \[
   \inferrule{\neg(F_1 \xor F_2) \mid -}{F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#NOT_XOR_ELIM2">NOT_XOR_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Not XOR elimination version 2
 
 \[
   \inferrule{\neg(F_1 \xor F_2) \mid -}{\neg F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RE_INTER">RE_INTER</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Regular expressions &ndash; Intersection
 
 \[
 
   \inferrule{t\in R_1,\,t\in R_2\mid -}{t\in \mathit{re.inter}(R_1,R_2)}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RE_UNFOLD_NEG">RE_UNFOLD_NEG</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Regular expressions &ndash; Negative Unfold
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{*}(R) \mid -}{t \neq \ \epsilon \ \wedge \forall L.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RE_UNFOLD_NEG_CONCAT_FIXED">RE_UNFOLD_NEG_CONCAT_FIXED</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Regular expressions &ndash; Unfold negative concatenation, fixed
 
 ..</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RE_UNFOLD_POS">RE_UNFOLD_POS</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Regular expressions &ndash; Positive Unfold
 
 \[
 
   \inferrule{t\in R\mid -}{F}
 \]
 where \(F\) corresponds to the one-step unfolding of the premise.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#REFL">REFL</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Reflexivity
 
 \[
 
   \inferrule{-\mid t}{t = t}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#REORDERING">REORDERING</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Reordering
 
 \[
   \inferrule{C_1 \mid C_2}{C_2}
 \]
 where
 the set representations of \(C_1\) and \(C_2\) are the same and the
 number of literals in \(C_2\) is the same of that of \(C_1\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#RESOLUTION">RESOLUTION</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Resolution
 
 \[
   \inferrule{C_1, C_2 \mid pol, L}{C}
 \]
 where
 
 
 \(C_1\) and \(C_2\) are nodes viewed as clauses, i.e., either an
   <code>OR</code> node with each children viewed as a literal or a node viewed as a
   literal.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SAT_EXTERNAL_PROVE">SAT_EXTERNAL_PROVE</a></span></code></th>
<td class="colLast">
<div class="block">SAT external prove Refutation
 
 \[
   \inferrule{F_1 \dots F_n \mid D}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the input clauses in the
 DIMACS file `D`.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SAT_REFUTATION">SAT_REFUTATION</a></span></code></th>
<td class="colLast">
<div class="block">SAT Refutation for assumption-based unsat cores
 
 \[
   \inferrule{F_1 \dots F_n \mid -}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the unsat core determined by the
 SAT solver.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SCOPE">SCOPE</a></span></code></th>
<td class="colLast">
<div class="block">Scope (a binder for assumptions)
 
 \[
 
   \inferruleSC{F \mid F_1 \dots F_n}{(F_1 \land \dots \land F_n)
   \Rightarrow F}{if $F\neq\bot$} \textrm{ or } \inferruleSC{F \mid F_1
   \dots F_n}{\neg (F_1 \land \dots \land F_n)}{if $F=\bot$}
 \]
 This rule has a dual purpose with
 ASSUME &lt;cvc5.<a href="#ASSUME"><code>ASSUME</code></a>&gt;.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SETS_EXT">SETS_EXT</a></span></code></th>
<td class="colLast">
<div class="block">Sets &ndash; Sets extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{set.member}(k,a)\neq\mathit{set.member}(k,b)}
 \]
 where \(k\) is the \(\texttt{SETS_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SETS_SINGLETON_INJ">SETS_SINGLETON_INJ</a></span></code></th>
<td class="colLast">
<div class="block">Sets &ndash; Singleton injectivity
 
 \[
 
   \inferrule{\mathit{set.singleton}(t) = \mathit{set.singleton}(s)\mid -}{t=s}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SKOLEM_INTRO">SKOLEM_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Quantifiers &ndash; Skolem introduction
 
 \[
 
   \inferrule{-\mid k}{k = t}
 \]
 where \(t\) is the unpurified form of skolem \(k\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SKOLEMIZE">SKOLEMIZE</a></span></code></th>
<td class="colLast">
<div class="block">Quantifiers &ndash; Skolemization
 
 \[
 
   \inferrule{\neg (\forall x_1\dots x_n.\&gt; F)\mid -}{\neg F\sigma}
 \]
 where \(\sigma\) maps \(x_1,\dots,x_n\) to their representative
 skolems, which are skolems \(k_1,\dots,k_n\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SPLIT">SPLIT</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; Split
 
 \[
   \inferrule{- \mid F}{F \lor \neg F}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_CODE_INJ">STRING_CODE_INJ</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Code points
 
 \[
 
   \inferrule{-\mid t,s}{\mathit{to\_code}(t) = -1 \vee \mathit{to\_code}(t) \neq
   \mathit{to\_code}(s) \vee t = s}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_DECOMPOSE">STRING_DECOMPOSE</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; String decomposition
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \bot}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_1) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\)
 and \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_EAGER_REDUCTION">STRING_EAGER_REDUCTION</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Extended functions &ndash; Eager reduction
 
 \[
 
   \inferrule{-\mid t}{R}
 \]
 where \(R\) is \(\texttt{TermRegistry::eagerReduce}(t)\).</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_LENGTH_NON_EMPTY">STRING_LENGTH_NON_EMPTY</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Length non-empty
 
 \[
 
   \inferrule{t\neq \epsilon\mid -}{\mathit{len}(t) \neq 0}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_LENGTH_POS">STRING_LENGTH_POS</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Core rules &ndash; Length positive
 
 \[
 
   \inferrule{-\mid t}{(\mathit{len}(t) = 0\wedge t= \epsilon)\vee \mathit{len}(t)
   &gt; 0}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_REDUCTION">STRING_REDUCTION</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Extended functions &ndash; Reduction
 
 \[
 
   \inferrule{-\mid t}{R\wedge t = w}
 \]
 where \(w\) is \(\texttt{StringsPreprocess::reduce}(t, R,
 \dots)\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#STRING_SEQ_UNIT_INJ">STRING_SEQ_UNIT_INJ</a></span></code></th>
<td class="colLast">
<div class="block">Strings &ndash; Sequence unit
 
 \[
 
   \inferrule{\mathit{unit}(x) = \mathit{unit}(y)\mid -}{x = y}
 \]
 Also applies to the case where \(\mathit{unit}(y)\) is a constant
 sequence of length one.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SUBS">SUBS</a></span></code></th>
<td class="colLast">
<div class="block">Builtin theory &ndash; Substitution
 
 \[
 
   \inferrule{F_1 \dots F_n \mid t, ids?}{t = t \circ \sigma_{ids}(F_n)
   \circ \cdots \circ \sigma_{ids}(F_1)}
 \]
 where \(\sigma_{ids}(F_i)\) are substitutions, which notice are applied
 in reverse order.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#SYMM">SYMM</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Symmetry
 
 \[
 
   \inferrule{t_1 = t_2\mid -}{t_2 = t_1}
 \]
 or
 
 \[
 
   \inferrule{t_1 \neq t_2\mid -}{t_2 \neq t_1}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#THEORY_REWRITE">THEORY_REWRITE</a></span></code></th>
<td class="colLast">
<div class="block">Other theory rewrite rules
 
 \[
   \inferrule{- \mid id, t = t'}{t = t'}
 \]
 where `id` is the ProofRewriteRule of the theory rewrite
 rule which transforms \(t\) to \(t'\).</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#TRANS">TRANS</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; Transitivity
 
 \[
 
   \inferrule{t_1=t_2,\dots,t_{n-1}=t_n\mid -}{t_1 = t_n}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#TRUE_ELIM">TRUE_ELIM</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; True elim
 
 \[
 
   \inferrule{F=\top\mid -}{F}
 \]</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#TRUE_INTRO">TRUE_INTRO</a></span></code></th>
<td class="colLast">
<div class="block">Equality &ndash; True intro
 
 \[
 
   \inferrule{F\mid -}{F = \top}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#TRUST">TRUST</a></span></code></th>
<td class="colLast">
<div class="block">Trusted rule
 
 \[
   \inferrule{F_1 \dots F_n \mid tid, F, ...}{F}
 \]
 where \(tid\) is an identifier and \(F\) is a formula.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#TRUST_THEORY_REWRITE">TRUST_THEORY_REWRITE</a></span></code></th>
<td class="colLast">
<div class="block">Trusted rules &ndash; Theory rewrite
 
 \[
   \inferrule{- \mid F, tid, rid}{F}
 \]
 where \(F\) is an equality of the form \(t = t'\) where \(t'\)
 is obtained by applying the kind of rewriting given by the method
 identifier \(rid\), which is one of:
 <code>RW_REWRITE_THEORY_PRE</code>, <code>RW_REWRITE_THEORY_POST</code>,
 <code>RW_REWRITE_EQ_EXT</code>.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#UNKNOWN">UNKNOWN</a></span></code></th>
<td class="colLast">
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#XOR_ELIM1">XOR_ELIM1</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; XOR elimination version 1
 
 \[
   \inferrule{F_1 \xor F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><code><span class="memberNameLink"><a href="#XOR_ELIM2">XOR_ELIM2</a></span></code></th>
<td class="colLast">
<div class="block">Boolean &ndash; XOR elimination version 2
 
 \[
   \inferrule{F_1 \xor F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromInt(int)">fromInt</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getValue()">getValue</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#valueOf(java.lang.String)">valueOf</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Returns the enum constant of this type with the specified name.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#values()">values</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Enum">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Enum</h3>
<code>clone, compareTo, equals, finalize, getDeclaringClass, hashCode, name, ordinal, toString, valueOf</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ENUM CONSTANT DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="enum.constant.detail">
<!--   -->
</a>
<h3>Enum Constant Detail</h3>
<a id="ASSUME">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ASSUME</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ASSUME</pre>
<div class="block">Assumption (a leaf)
 
 \[
 
   \inferrule{- \mid F}{F}
 \]
 This rule has special status, in that an application of assume is an
 open leaf in a proof that is not (yet) justified. An assume leaf is
 analogous to a free variable in a term, where we say "F is a free
 assumption in proof P" if it contains an application of F that is not
 bound by SCOPE &lt;cvc5.<a href="#SCOPE"><code>SCOPE</code></a>&gt; (see below).</div>
</li>
</ul>
<a id="SCOPE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SCOPE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SCOPE</pre>
<div class="block">Scope (a binder for assumptions)
 
 \[
 
   \inferruleSC{F \mid F_1 \dots F_n}{(F_1 \land \dots \land F_n)
   \Rightarrow F}{if $F\neq\bot$} \textrm{ or } \inferruleSC{F \mid F_1
   \dots F_n}{\neg (F_1 \land \dots \land F_n)}{if $F=\bot$}
 \]
 This rule has a dual purpose with
 ASSUME &lt;cvc5.<a href="#ASSUME"><code>ASSUME</code></a>&gt;. It is a way to close
 assumptions in a proof. We require that \(F_1 \dots F_n\) are free
 assumptions in P and say that \(F_1 \dots F_n\) are not free in
 <code>(SCOPE P)</code>. In other words, they are bound by this application. For
 example, the proof node:
 <code>(SCOPE (ASSUME F) :args F)</code>
 has the conclusion \(F \Rightarrow F\) and has no free assumptions.
 More generally, a proof with no free assumptions always concludes a valid
 formula.</div>
</li>
</ul>
<a id="SUBS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SUBS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SUBS</pre>
<div class="block">Builtin theory &ndash; Substitution
 
 \[
 
   \inferrule{F_1 \dots F_n \mid t, ids?}{t = t \circ \sigma_{ids}(F_n)
   \circ \cdots \circ \sigma_{ids}(F_1)}
 \]
 where \(\sigma_{ids}(F_i)\) are substitutions, which notice are applied
 in reverse order. Notice that \(ids\) is a MethodId identifier, which
 determines how to convert the formulas \(F_1 \dots F_n\) into
 substitutions. It is an optional argument, where by default the premises
 are equalities of the form `(= x y)` and converted into substitutions
 \(x\mapsto y\).</div>
</li>
</ul>
<a id="MACRO_REWRITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_REWRITE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_REWRITE</pre>
<div class="block">Builtin theory &ndash; Rewrite
 
 \[
   \inferrule{- \mid t, idr}{t = \texttt{rewrite}_{idr}(t)}
 \]
 where \(idr\) is a MethodId identifier, which determines the kind of
 rewriter to apply, e.g. Rewriter.rewrite.</div>
</li>
</ul>
<a id="EVALUATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EVALUATE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> EVALUATE</pre>
<div class="block">Builtin theory &ndash; Evaluate
 
 \[
   \inferrule{- \mid t}{t = \texttt{evaluate}(t)}
 \]
 where \(\texttt{evaluate}\) is implemented by calling the method
 \(\texttt{Evalutor::evaluate}\) in :cvc5src:`theory/evaluator.h` with an
 empty substitution.
 Note this is equivalent to: <code>(REWRITE t {@link MethodId#RW_EVALUATE)}</code>.</div>
</li>
</ul>
<a id="ACI_NORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ACI_NORM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ACI_NORM</pre>
<div class="block">Builtin theory &ndash; associative/commutative/idempotency/identity normalization
 
 \[
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{expr::isACNorm(t, s)} = \top\). For details, see
 :cvc5src:`expr/nary_term_util.h`.
 This method normalizes currently based on two kinds of operators:
 (1) those that are associative, commutative, idempotent, and have an
 identity element (examples are or, and, bvand),
 (2) those that are associative and have an identity element (examples
 are str.++, re.++).</div>
</li>
</ul>
<a id="MACRO_SR_EQ_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_SR_EQ_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_SR_EQ_INTRO</pre>
<div class="block">Builtin theory &ndash; Substitution + Rewriting equality introduction
 
 In this rule, we provide a term \(t\) and conclude that it is equal to
 its rewritten form under a (proven) substitution.
 
 \[
   \inferrule{F_1 \dots F_n \mid t, (ids (ida (idr)?)?)?}{t =
   \texttt{rewrite}_{idr}(t \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ
   \sigma_{ids, ida}(F_1))}
 \]
 In other words, from the point of view of Skolem forms, this rule
 transforms \(t\) to \(t'\) by standard substitution + rewriting.
 
 The arguments \(ids\), \(ida\) and \(idr\) are optional and
 specify the identifier of the substitution, the substitution application
 and rewriter respectively to be used. For details, see
 :cvc5src:`theory/builtin/proof_checker.h`.</div>
</li>
</ul>
<a id="MACRO_SR_PRED_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_SR_PRED_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_SR_PRED_INTRO</pre>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate introduction
 
 In this rule, we provide a formula \(F\) and conclude it, under the
 condition that it rewrites to true under a proven substitution.
 
 \[
   \inferrule{F_1 \dots F_n \mid F, (ids (ida (idr)?)?)?}{F}
 \]
 where \(\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
 \cdots \circ \sigma_{ids, ida}(F_1)) = \top\) and \(ids\) and
 \(idr\) are method identifiers.
 
 More generally, this rule also holds when
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \top\)
 where \(F'\) is the result of the left hand side of the equality above.
 Here, notice that we apply rewriting on the original form of \(F'\),
 meaning that this rule may conclude an \(F\) whose Skolem form is
 justified by the definition of its (fresh) Skolem variables. For example,
 this rule may justify the conclusion \(k = t\) where \(k\) is the
 purification Skolem for \(t\), e.g. where the original form of
 \(k\) is \(t\).
 
 Furthermore, notice that the rewriting and substitution is applied only
 within the side condition, meaning the rewritten form of the original form
 of \(F\) does not escape this rule.</div>
</li>
</ul>
<a id="MACRO_SR_PRED_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_SR_PRED_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_SR_PRED_ELIM</pre>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
   \inferrule{F, F_1 \dots F_n \mid (ids (ida
   (idr)?)?)?}{\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
   \cdots \circ \sigma_{ids, ida}(F_1))}
 \]
 where \(ids\) and \(idr\) are method identifiers.
 
 We rewrite only on the Skolem form of \(F\), similar to
 MACRO_SR_EQ_INTRO &lt;cvc5.<a href="#MACRO_SR_EQ_INTRO"><code>MACRO_SR_EQ_INTRO</code></a>&gt;.</div>
</li>
</ul>
<a id="MACRO_SR_PRED_TRANSFORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_SR_PRED_TRANSFORM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_SR_PRED_TRANSFORM</pre>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
   \inferrule{F, F_1 \dots F_n \mid G, (ids (ida (idr)?)?)?}{G}
 \]
 where
 
 \[
   \texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ\cdots \circ \sigma_{ids, ida}(F_1)) =\\ \texttt{rewrite}_{idr}(G \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ \sigma_{ids, ida}(F_1))
 \]
 More generally, this rule also holds when:
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \texttt{Rewriter::rewrite}(\texttt{toOriginal}(G'))\)
 where \(F'\) and \(G'\) are the result of each side of the equation
 above. Here, original forms are used in a similar manner to
 MACRO_SR_PRED_INTRO &lt;cvc5.<a href="#MACRO_SR_PRED_INTRO"><code>MACRO_SR_PRED_INTRO</code></a>&gt;
 above.</div>
</li>
</ul>
<a id="ENCODE_EQ_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ENCODE_EQ_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ENCODE_EQ_INTRO</pre>
<div class="block">Builtin theory &ndash; Encode equality introduction
 
 \[
   \inferrule{- \mid t}{t=t'}
 \]
 where \(t\) and \(t'\) are equivalent up to their encoding in an
 external proof format.
 
 More specifically, it is the case that
 \(\texttt{RewriteDbNodeConverter::postConvert}(t) = t;\).
 This conversion method for instance may drop user patterns from quantified
 formulas or change the representation of \(t\) in a way that is a
 no-op in external proof formats.
 
 Note this rule can be treated as a
 REFL &lt;cvc5.<a href="#REFL"><code>REFL</code></a>&gt; when appropriate in
 external proof formats.</div>
</li>
</ul>
<a id="DSL_REWRITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DSL_REWRITE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> DSL_REWRITE</pre>
<div class="block">Builtin theory &ndash; DSL rewrite
 
 \[
   \inferrule{F_1 \dots F_n \mid id t_1 \dots t_n}{F}
 \]
 where `id` is a ProofRewriteRule whose definition in the
 RARE DSL is \(\forall x_1 \dots x_n. (G_1 \wedge G_n) \Rightarrow G\)
 where for \(i=1, \dots n\), we have that \(F_i = \sigma(G_i)\)
 and \(F = \sigma(G)\) where \(\sigma\) is the substitution
 \(\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}\).
 
 Notice that the application of the substitution takes into account the
 possible list semantics of variables \(x_1 \ldots x_n\). If
 \(x_i\) is a variable with list semantics, then \(t_i\) denotes a
 list of terms. The substitution implemented by
 \(\texttt{expr::narySubstitute}\) (for details, see
 :cvc5src:`expr/nary_term_util.h`) which replaces each \(x_i\) with the
 list \(t_i\) in its place.</div>
</li>
</ul>
<a id="THEORY_REWRITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THEORY_REWRITE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> THEORY_REWRITE</pre>
<div class="block">Other theory rewrite rules
 
 \[
   \inferrule{- \mid id, t = t'}{t = t'}
 \]
 where `id` is the ProofRewriteRule of the theory rewrite
 rule which transforms \(t\) to \(t'\).
 
 In contrast to DSL_REWRITE, theory rewrite rules used by
 this proof rule are not necessarily expressible in RARE. Each rule that can
 be used in this proof rule are documented explicitly in cases within the
 ProofRewriteRule enum.</div>
</li>
</ul>
<a id="ANNOTATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ANNOTATION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ANNOTATION</pre>
<div class="block">Builtin theory &ndash; Annotation
 
 \[
   \inferrule{F \mid a_1 \dots a_n}{F}
 \]
 The terms \(a_1 \dots a_n\) can be anything used to annotate the proof
 node, one example is where \(a_1\) is a theory.InferenceId.</div>
</li>
</ul>
<a id="ITE_EQ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ITE_EQ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ITE_EQ</pre>
<div class="block">Processing rules &ndash; If-then-else equivalence
 
 \[
   \inferrule{- \mid \ite{C}{t_1}{t_2}}{\ite{C}{((\ite{C}{t_1}{t_2}) = t_1)}{((\ite{C}{t_1}{t_2}) = t_2)}}
 \]</div>
</li>
</ul>
<a id="TRUST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TRUST</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> TRUST</pre>
<div class="block">Trusted rule
 
 \[
   \inferrule{F_1 \dots F_n \mid tid, F, ...}{F}
 \]
 where \(tid\) is an identifier and \(F\) is a formula. This rule
 is used when a formal justification of an inference step cannot be provided.
 The formulas \(F_1 \dots F_n\) refer to a set of formulas that
 entail \(F\), which may or may not be provided.</div>
</li>
</ul>
<a id="TRUST_THEORY_REWRITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TRUST_THEORY_REWRITE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> TRUST_THEORY_REWRITE</pre>
<div class="block">Trusted rules &ndash; Theory rewrite
 
 \[
   \inferrule{- \mid F, tid, rid}{F}
 \]
 where \(F\) is an equality of the form \(t = t'\) where \(t'\)
 is obtained by applying the kind of rewriting given by the method
 identifier \(rid\), which is one of:
 <code>RW_REWRITE_THEORY_PRE</code>, <code>RW_REWRITE_THEORY_POST</code>,
 <code>RW_REWRITE_EQ_EXT</code>. Notice that the checker for this rule does not
 replay the rewrite to ensure correctness, since theory rewriter methods are
 not static. For example, the quantifiers rewriter involves constructing new
 bound variables that are not guaranteed to be consistent on each call.</div>
</li>
</ul>
<a id="SAT_REFUTATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAT_REFUTATION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SAT_REFUTATION</pre>
<div class="block">SAT Refutation for assumption-based unsat cores
 
 \[
   \inferrule{F_1 \dots F_n \mid -}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the unsat core determined by the
 SAT solver.</div>
</li>
</ul>
<a id="DRAT_REFUTATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DRAT_REFUTATION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> DRAT_REFUTATION</pre>
<div class="block">DRAT Refutation
 
 \[
   \inferrule{F_1 \dots F_n \mid D, P}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the clauses in the
 DIMACS file given by filename `D` and `P` is a filename of a file storing
 a DRAT proof.</div>
</li>
</ul>
<a id="SAT_EXTERNAL_PROVE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SAT_EXTERNAL_PROVE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SAT_EXTERNAL_PROVE</pre>
<div class="block">SAT external prove Refutation
 
 \[
   \inferrule{F_1 \dots F_n \mid D}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the input clauses in the
 DIMACS file `D`.</div>
</li>
</ul>
<a id="RESOLUTION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RESOLUTION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> RESOLUTION</pre>
<div class="block">Boolean &ndash; Resolution
 
 \[
   \inferrule{C_1, C_2 \mid pol, L}{C}
 \]
 where
 
 <ul>
 <li>\(C_1\) and \(C_2\) are nodes viewed as clauses, i.e., either an
   <code>OR</code> node with each children viewed as a literal or a node viewed as a
   literal. Note that an <code>OR</code> node could also be a literal.
 </li>
 <li>\(pol\) is either true or false, representing the polarity of the
   pivot on the first clause
 </li>
 <li>\(L\) is the pivot of the resolution, which occurs as is (resp. under
   a <code>NOT</code>) in \(C_1\) and negatively (as is) in \(C_2\) if
   \(pol = \top\) (\(pol = \bot\)).
 
 </li></ul>
 \(C\) is a clause resulting from collecting all the literals in
 \(C_1\), minus the first occurrence of the pivot or its negation, and
 \(C_2\), minus the first occurrence of the pivot or its negation,
 according to the policy above. If the resulting clause has a single
 literal, that literal itself is the result; if it has no literals, then the
 result is false; otherwise it's an <code>OR</code> node of the resulting literals.
 
 Note that it may be the case that the pivot does not occur in the
 clauses. In this case the rule is not unsound, but it does not correspond
 to resolution but rather to a weakening of the clause that did not have a
 literal eliminated.</div>
</li>
</ul>
<a id="CHAIN_RESOLUTION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN_RESOLUTION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CHAIN_RESOLUTION</pre>
<div class="block">Boolean &ndash; N-ary Resolution
 
 \[
   \inferrule{C_1 \dots C_n \mid (pol_1 \dots pol_{n-1}), (L_1 \dots L_{n-1})}{C}
 \]
 where
 
 <ul>
 <li>let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined above
 </li>
 <li>let \(C_1 \diamond_{L,pol} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined above
 </li>
 <li>let \(C_1' = C_1\),
 </li>
 <li>for each \(i &gt; 1\), let \(C_i' = C_{i-1} \diamond_{L_{i-1}, pol_{i-1}} C_i'\)
 
 </li></ul>
 Note the list of polarities and pivots are provided as s-expressions.
 
 The result of the chain resolution is \(C = C_n'\)</div>
</li>
</ul>
<a id="FACTORING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FACTORING</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> FACTORING</pre>
<div class="block">Boolean &ndash; Factoring
 
 \[
   \inferrule{C_1 \mid -}{C_2}
 \]
 where \(C_2\) is the clause \(C_1\), but every occurrence of a literal
 after its first occurrence is omitted.</div>
</li>
</ul>
<a id="REORDERING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REORDERING</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> REORDERING</pre>
<div class="block">Boolean &ndash; Reordering
 
 \[
   \inferrule{C_1 \mid C_2}{C_2}
 \]
 where
 the set representations of \(C_1\) and \(C_2\) are the same and the
 number of literals in \(C_2\) is the same of that of \(C_1\).</div>
</li>
</ul>
<a id="MACRO_RESOLUTION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_RESOLUTION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_RESOLUTION</pre>
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering
 
 \[
   \inferrule{C_1 \dots C_n \mid C, pol_1,L_1 \dots pol_{n-1},L_{n-1}}{C}
 \]
 where
 
 <ul>
 <li>let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1 \diamond_{L,\mathit{pol}} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1'\) be equal, in its set representation, to \(C_1\),
 </li>
 <li>for each \(i &gt; 1\), let \(C_i'\) be equal, in its set
   representation, to \(C_{i-1} \diamond_{L_{i-1},\mathit{pol}_{i-1}}
   C_i'\)
 
 </li></ul>
 The result of the chain resolution is \(C\), which is equal, in its set
 representation, to \(C_n'\)</div>
</li>
</ul>
<a id="MACRO_RESOLUTION_TRUST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_RESOLUTION_TRUST</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_RESOLUTION_TRUST</pre>
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering unchecked
 
 Same as
 MACRO_RESOLUTION &lt;cvc5.<a href="#MACRO_RESOLUTION"><code>MACRO_RESOLUTION</code></a>&gt;, but
 not checked by the internal proof checker.</div>
</li>
</ul>
<a id="SPLIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SPLIT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SPLIT</pre>
<div class="block">Boolean &ndash; Split
 
 \[
   \inferrule{- \mid F}{F \lor \neg F}
 \]</div>
</li>
</ul>
<a id="EQ_RESOLVE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EQ_RESOLVE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> EQ_RESOLVE</pre>
<div class="block">Boolean &ndash; Equality resolution
 
 \[
   \inferrule{F_1, (F_1 = F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 EQUIV_ELIM1 &lt;cvc5.<a href="#EQUIV_ELIM1"><code>EQUIV_ELIM1</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</li>
</ul>
<a id="MODUS_PONENS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MODUS_PONENS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MODUS_PONENS</pre>
<div class="block">Boolean &ndash; Modus Ponens
 
 \[
   \inferrule{F_1, (F_1 \rightarrow F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 IMPLIES_ELIM &lt;cvc5.<a href="#IMPLIES_ELIM"><code>IMPLIES_ELIM</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</li>
</ul>
<a id="NOT_NOT_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_NOT_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_NOT_ELIM</pre>
<div class="block">Boolean &ndash; Double negation elimination
 
 \[
   \inferrule{\neg (\neg F) \mid -}{F}
 \]</div>
</li>
</ul>
<a id="CONTRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONTRA</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONTRA</pre>
<div class="block">Boolean &ndash; Contradiction
 
 \[
   \inferrule{F, \neg F \mid -}{\bot}
 \]</div>
</li>
</ul>
<a id="AND_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AND_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> AND_ELIM</pre>
<div class="block">Boolean &ndash; And elimination
 
 \[
   \inferrule{(F_1 \land \dots \land F_n) \mid i}{F_i}
 \]</div>
</li>
</ul>
<a id="AND_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AND_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> AND_INTRO</pre>
<div class="block">Boolean &ndash; And introduction
 
 \[
   \inferrule{F_1 \dots F_n \mid -}{(F_1 \land \dots \land F_n)}
 \]</div>
</li>
</ul>
<a id="NOT_OR_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_OR_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_OR_ELIM</pre>
<div class="block">Boolean &ndash; Not Or elimination
 
 \[
   \inferrule{\neg(F_1 \lor \dots \lor F_n) \mid i}{\neg F_i}
 \]</div>
</li>
</ul>
<a id="IMPLIES_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IMPLIES_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> IMPLIES_ELIM</pre>
<div class="block">Boolean &ndash; Implication elimination
 
 \[
   \inferrule{F_1 \rightarrow F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="NOT_IMPLIES_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_IMPLIES_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_IMPLIES_ELIM1</pre>
<div class="block">Boolean &ndash; Not Implication elimination version 1
 
 \[
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{F_1}
 \]</div>
</li>
</ul>
<a id="NOT_IMPLIES_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_IMPLIES_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_IMPLIES_ELIM2</pre>
<div class="block">Boolean &ndash; Not Implication elimination version 2
 
 \[
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{\neg F_2}
 \]</div>
</li>
</ul>
<a id="EQUIV_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EQUIV_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> EQUIV_ELIM1</pre>
<div class="block">Boolean &ndash; Equivalence elimination version 1
 
 \[
   \inferrule{F_1 = F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="EQUIV_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EQUIV_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> EQUIV_ELIM2</pre>
<div class="block">Boolean &ndash; Equivalence elimination version 2
 
 \[
   \inferrule{F_1 = F_2 \mid -}{F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="NOT_EQUIV_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_EQUIV_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_EQUIV_ELIM1</pre>
<div class="block">Boolean &ndash; Not Equivalence elimination version 1
 
 \[
   \inferrule{F_1 \neq F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="NOT_EQUIV_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_EQUIV_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_EQUIV_ELIM2</pre>
<div class="block">Boolean &ndash; Not Equivalence elimination version 2
 
 \[
   \inferrule{F_1 \neq F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="XOR_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>XOR_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> XOR_ELIM1</pre>
<div class="block">Boolean &ndash; XOR elimination version 1
 
 \[
   \inferrule{F_1 \xor F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="XOR_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>XOR_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> XOR_ELIM2</pre>
<div class="block">Boolean &ndash; XOR elimination version 2
 
 \[
   \inferrule{F_1 \xor F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="NOT_XOR_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_XOR_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_XOR_ELIM1</pre>
<div class="block">Boolean &ndash; Not XOR elimination version 1
 
 \[
   \inferrule{\neg(F_1 \xor F_2) \mid -}{F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="NOT_XOR_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_XOR_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_XOR_ELIM2</pre>
<div class="block">Boolean &ndash; Not XOR elimination version 2
 
 \[
   \inferrule{\neg(F_1 \xor F_2) \mid -}{\neg F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="ITE_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ITE_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ITE_ELIM1</pre>
<div class="block">Boolean &ndash; ITE elimination version 1
 
 \[
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor F_1}
 \]</div>
</li>
</ul>
<a id="ITE_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ITE_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ITE_ELIM2</pre>
<div class="block">Boolean &ndash; ITE elimination version 2
 
 \[
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{C \lor F_2}
 \]</div>
</li>
</ul>
<a id="NOT_ITE_ELIM1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_ITE_ELIM1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_ITE_ELIM1</pre>
<div class="block">Boolean &ndash; Not ITE elimination version 1
 
 \[
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor \neg F_1}
 \]</div>
</li>
</ul>
<a id="NOT_ITE_ELIM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_ITE_ELIM2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_ITE_ELIM2</pre>
<div class="block">Boolean &ndash; Not ITE elimination version 2
 
 \[
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{C \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="NOT_AND">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NOT_AND</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NOT_AND</pre>
<div class="block">Boolean &ndash; De Morgan &ndash; Not And
 
 \[
   \inferrule{\neg(F_1 \land \dots \land F_n) \mid -}{\neg F_1 \lor \dots
   \lor \neg F_n}
 \]</div>
</li>
</ul>
<a id="CNF_AND_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_AND_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_AND_POS</pre>
<div class="block">Boolean &ndash; CNF &ndash; And Positive
 
 \[
   \inferrule{- \mid (F_1 \land \dots \land F_n), i}{\neg (F_1 \land \dots
   \land F_n) \lor F_i}
 \]</div>
</li>
</ul>
<a id="CNF_AND_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_AND_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_AND_NEG</pre>
<div class="block">Boolean &ndash; CNF &ndash; And Negative
 
 \[
   \inferrule{- \mid (F_1 \land \dots \land F_n)}{(F_1 \land \dots \land
   F_n) \lor \neg F_1 \lor \dots \lor \neg F_n}
 \]</div>
</li>
</ul>
<a id="CNF_OR_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_OR_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_OR_POS</pre>
<div class="block">Boolean &ndash; CNF &ndash; Or Positive
 
 \[
   \inferrule{- \mid (F_1 \lor \dots \lor F_n)}{\neg(F_1 \lor \dots \lor
   F_n) \lor F_1 \lor \dots \lor F_n}
 \]</div>
</li>
</ul>
<a id="CNF_OR_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_OR_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_OR_NEG</pre>
<div class="block">Boolean &ndash; CNF &ndash; Or Negative
 
 \[
   \inferrule{- \mid (F_1 \lor \dots \lor F_n), i}{(F_1 \lor \dots \lor F_n)
   \lor \neg F_i}
 \]</div>
</li>
</ul>
<a id="CNF_IMPLIES_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_IMPLIES_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_IMPLIES_POS</pre>
<div class="block">Boolean &ndash; CNF &ndash; Implies Positive
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{\neg(F_1 \rightarrow F_2) \lor \neg F_1
   \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_IMPLIES_NEG1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_IMPLIES_NEG1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_IMPLIES_NEG1</pre>
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 1
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor F_1}
 \]</div>
</li>
</ul>
<a id="CNF_IMPLIES_NEG2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_IMPLIES_NEG2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_IMPLIES_NEG2</pre>
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 2
 
 \[
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_EQUIV_POS1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_EQUIV_POS1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_EQUIV_POS1</pre>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 1
 
 \[
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor \neg F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_EQUIV_POS2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_EQUIV_POS2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_EQUIV_POS2</pre>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 2
 
 \[
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_EQUIV_NEG1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_EQUIV_NEG1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_EQUIV_NEG1</pre>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 1
 
 \[
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_EQUIV_NEG2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_EQUIV_NEG2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_EQUIV_NEG2</pre>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 2
 
 \[
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor \neg F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_XOR_POS1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_XOR_POS1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_XOR_POS1</pre>
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 1
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_XOR_POS2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_XOR_POS2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_XOR_POS2</pre>
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 2
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor \neg F_1 \lor
   \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_XOR_NEG1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_XOR_NEG1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_XOR_NEG1</pre>
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 1
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor \neg F_1 \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_XOR_NEG2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_XOR_NEG2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_XOR_NEG2</pre>
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 2
 
 \[
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor F_1 \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_POS1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_POS1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_POS1</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 1
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor \neg
   C \lor F_1}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_POS2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_POS2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_POS2</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 2
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor C
   \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_POS3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_POS3</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_POS3</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 3
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor F_1
   \lor F_2}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_NEG1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_NEG1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_NEG1</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 1
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg C
   \lor \neg F_1}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_NEG2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_NEG2</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_NEG2</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 2
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor C \lor
   \neg F_2}
 \]</div>
</li>
</ul>
<a id="CNF_ITE_NEG3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CNF_ITE_NEG3</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CNF_ITE_NEG3</pre>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 3
 
 \[
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg F_1
   \lor \neg F_2}
 \]</div>
</li>
</ul>
<a id="REFL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REFL</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> REFL</pre>
<div class="block">Equality &ndash; Reflexivity
 
 \[
 
   \inferrule{-\mid t}{t = t}
 \]</div>
</li>
</ul>
<a id="SYMM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SYMM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SYMM</pre>
<div class="block">Equality &ndash; Symmetry
 
 \[
 
   \inferrule{t_1 = t_2\mid -}{t_2 = t_1}
 \]
 or
 
 \[
 
   \inferrule{t_1 \neq t_2\mid -}{t_2 \neq t_1}
 \]</div>
</li>
</ul>
<a id="TRANS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TRANS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> TRANS</pre>
<div class="block">Equality &ndash; Transitivity
 
 \[
 
   \inferrule{t_1=t_2,\dots,t_{n-1}=t_n\mid -}{t_1 = t_n}
 \]</div>
</li>
</ul>
<a id="CONG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONG</pre>
<div class="block">Equality &ndash; Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid k, f?}{k(f?, t_1,\dots, t_n) =
   k(f?, s_1,\dots, s_n)}
 \]
 where \(k\) is the application kind. Notice that \(f\) must be
 provided iff \(k\) is a parameterized kind, e.g.
 `cvc5.Kind.APPLY_UF`. The actual node for
 \(k\) is constructible via <code>ProofRuleChecker.mkKindNode</code>.
 If \(k\) is a binder kind (e.g. <code>cvc5.{@link Kind#FORALL})</code> then \(f\)
 is a term of kind <code>cvc5.Kind.VARIABLE_LIST</code>
 denoting the variables bound by both sides of the conclusion.
 This rule is used for kinds that have a fixed arity, such as
 <code>cvc5.Kind.ITE</code>, <code>cvc5.Kind.EQUAL</code>, and so on. It is also used for
 <code>cvc5.Kind.APPLY_UF</code> where \(f\) must be provided.
 It is not used for equality between
 <code>cvc5.Kind.HO_APPLY</code> terms, which should
 use the HO_CONG &lt;cvc5.<a href="#HO_CONG"><code>HO_CONG</code></a>&gt; proof rule.</div>
</li>
</ul>
<a id="NARY_CONG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NARY_CONG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> NARY_CONG</pre>
<div class="block">Equality &ndash; N-ary Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid k}{k(t_1,\dots, t_n) =
   k(s_1,\dots, s_n)}
 \]
 where \(k\) is the application kind. The actual node for \(k\) is
 constructible via <code>ProofRuleChecker.mkKindNode</code>. This rule is used for
 kinds that have variadic arity, such as <code>cvc5.Kind.AND</code>,
 <code>cvc5.Kind.PLUS</code> and so on.</div>
</li>
</ul>
<a id="TRUE_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TRUE_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> TRUE_INTRO</pre>
<div class="block">Equality &ndash; True intro
 
 \[
 
   \inferrule{F\mid -}{F = \top}
 \]</div>
</li>
</ul>
<a id="TRUE_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TRUE_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> TRUE_ELIM</pre>
<div class="block">Equality &ndash; True elim
 
 \[
 
   \inferrule{F=\top\mid -}{F}
 \]</div>
</li>
</ul>
<a id="FALSE_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FALSE_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> FALSE_INTRO</pre>
<div class="block">Equality &ndash; False intro
 
 \[
 
   \inferrule{\neg F\mid -}{F = \bot}
 \]</div>
</li>
</ul>
<a id="FALSE_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FALSE_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> FALSE_ELIM</pre>
<div class="block">Equality &ndash; False elim
 
 \[
 
   \inferrule{F=\bot\mid -}{\neg F}
 \]</div>
</li>
</ul>
<a id="HO_APP_ENCODE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HO_APP_ENCODE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> HO_APP_ENCODE</pre>
<div class="block">Equality &ndash; Higher-order application encoding
 
 \[
 
   \inferrule{-\mid t}{t=t'}
 \]
 where `t'` is the higher-order application that is equivalent to `t`,
 as implemented by <code>uf.TheoryUfRewriter.getHoApplyForApplyUf</code>.
 For details see :cvc5src:`theory/uf/theory_uf_rewriter.h`
 
 For example, this rule concludes \(f(x,y) = @( @(f,x), y)\), where
 \(@\) is the <code>HO_APPLY</code> kind.
 
 Note this rule can be treated as a
 REFL &lt;cvc5.<a href="#REFL"><code>REFL</code></a>&gt; when appropriate in
 external proof formats.</div>
</li>
</ul>
<a id="HO_CONG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HO_CONG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> HO_CONG</pre>
<div class="block">Equality &ndash; Higher-order congruence
 
 \[
 
   \inferrule{f=g, t_1=s_1,\dots,t_n=s_n\mid k}{k(f, t_1,\dots, t_n) =
   k(g, s_1,\dots, s_n)}
 \]
 Notice that this rule is only used when the application kind \(k\) is
 either `cvc5.Kind.APPLY_UF` or `cvc5.Kind.HO_APPLY`.</div>
</li>
</ul>
<a id="ARRAYS_READ_OVER_WRITE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARRAYS_READ_OVER_WRITE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARRAYS_READ_OVER_WRITE</pre>
<div class="block">Arrays &ndash; Read over write
 
 \[
 
   \inferrule{i_1 \neq i_2\mid \mathit{select}(\mathit{store}(a,i_1,e),i_2)}
   {\mathit{select}(\mathit{store}(a,i_1,e),i_2) = \mathit{select}(a,i_2)}
 \]</div>
</li>
</ul>
<a id="ARRAYS_READ_OVER_WRITE_CONTRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARRAYS_READ_OVER_WRITE_CONTRA</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARRAYS_READ_OVER_WRITE_CONTRA</pre>
<div class="block">Arrays &ndash; Read over write, contrapositive
 
 \[
 
   \inferrule{\mathit{select}(\mathit{store}(a,i_2,e),i_1) \neq
   \mathit{select}(a,i_1)\mid -}{i_1=i_2}
 \]</div>
</li>
</ul>
<a id="ARRAYS_READ_OVER_WRITE_1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARRAYS_READ_OVER_WRITE_1</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARRAYS_READ_OVER_WRITE_1</pre>
<div class="block">Arrays &ndash; Read over write 1
 
 \[
 
   \inferrule{-\mid \mathit{select}(\mathit{store}(a,i,e),i)}
   {\mathit{select}(\mathit{store}(a,i,e),i)=e}
 \]</div>
</li>
</ul>
<a id="ARRAYS_EXT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARRAYS_EXT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARRAYS_EXT</pre>
<div class="block">Arrays &ndash; Arrays extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{select}(a,k)\neq\mathit{select}(b,k)}
 \]
 where \(k\) is the \(\texttt{ARRAY_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</li>
</ul>
<a id="MACRO_BV_BITBLAST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_BV_BITBLAST</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_BV_BITBLAST</pre>
<div class="block">Bit-vectors &ndash; (Macro) Bitblast
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 where \(\texttt{bitblast}\) represents the result of the bit-blasted term as
 a bit-vector consisting of the output bits of the bit-blasted circuit
 representation of the term. Terms are bit-blasted according to the
 strategies defined in :cvc5src:`theory/bv/bitblast/bitblast_strategies_template.h`.</div>
</li>
</ul>
<a id="BV_BITBLAST_STEP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BV_BITBLAST_STEP</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> BV_BITBLAST_STEP</pre>
<div class="block">Bit-vectors &ndash; Bitblast bit-vector constant, variable, and terms
 
 For constant and variables:
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 For terms:
 
 \[
 
   \inferrule{-\mid k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n))}
   {k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n)) =
   \texttt{bitblast}(t)}
 \]
 where \(t\) is \(k(t_1,\dots,t_n)\).</div>
</li>
</ul>
<a id="BV_EAGER_ATOM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BV_EAGER_ATOM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> BV_EAGER_ATOM</pre>
<div class="block">Bit-vectors &ndash; Bit-vector eager atom
 
 \[
 
   \inferrule{-\mid F}{F = F[0]}
 \]
 where \(F\) is of kind <code>BITVECTOR_EAGER_ATOM</code>.</div>
</li>
</ul>
<a id="DT_UNIF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DT_UNIF</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> DT_UNIF</pre>
<div class="block">Datatypes &ndash; Unification
 
 \[
 
   \inferrule{C(t_1,\dots,t_n)= C(s_1,\dots,s_n)\mid i}{t_1 = s_i}
 \]
 where \(C\) is a constructor.</div>
</li>
</ul>
<a id="DT_SPLIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DT_SPLIT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> DT_SPLIT</pre>
<div class="block">Datatypes &ndash; Split
 
 \[
 
   \inferrule{-\mid t}{\mathit{is}_{C_1}(t)\vee\cdots\vee\mathit{is}_{C_n}(t)}
 \]
 where \(C_1,\dots,C_n\) are all the constructors of the type of \(t\).</div>
</li>
</ul>
<a id="DT_CLASH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DT_CLASH</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> DT_CLASH</pre>
<div class="block">Datatypes &ndash; Clash
 
 \[
 
   \inferruleSC{\mathit{is}_{C_i}(t), \mathit{is}_{C_j}(t)\mid -}{\bot}
   {if $i\neq j$}
 \]</div>
</li>
</ul>
<a id="SKOLEM_INTRO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SKOLEM_INTRO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SKOLEM_INTRO</pre>
<div class="block">Quantifiers &ndash; Skolem introduction
 
 \[
 
   \inferrule{-\mid k}{k = t}
 \]
 where \(t\) is the unpurified form of skolem \(k\).</div>
</li>
</ul>
<a id="SKOLEMIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SKOLEMIZE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SKOLEMIZE</pre>
<div class="block">Quantifiers &ndash; Skolemization
 
 \[
 
   \inferrule{\neg (\forall x_1\dots x_n.\&gt; F)\mid -}{\neg F\sigma}
 \]
 where \(\sigma\) maps \(x_1,\dots,x_n\) to their representative
 skolems, which are skolems \(k_1,\dots,k_n\). For each \(k_i\),
 its skolem identifier is QUANTIFIERS_SKOLEMIZE &lt;cvc5.<a href="SkolemId.html#QUANTIFIERS_SKOLEMIZE"><code>SkolemId.QUANTIFIERS_SKOLEMIZE</code></a>&gt;,
 and its indices are \((\forall x_1\dots x_n.\&gt; F)\) and \(x_i\).</div>
</li>
</ul>
<a id="INSTANTIATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INSTANTIATE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> INSTANTIATE</pre>
<div class="block">Quantifiers &ndash; Instantiation
 
 \[
 
   \inferrule{\forall x_1\dots x_n.\&gt; F\mid (t_1 \dots t_n), (id\, (t)?)?}
   {F\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}}
 \]
 The list of terms to instantiate \((t_1 \dots t_n)\) is provided as
 an s-expression as the first argument. The optional argument \(id\)
 indicates the inference id that caused the instantiation. The term
 \(t\) indicates an additional term (e.g. the trigger) associated with
 the instantiation, which depends on the id. If the id has prefix
 <code>QUANTIFIERS_INST_E_MATCHING</code>, then \(t\) is the trigger that
 generated the instantiation.</div>
</li>
</ul>
<a id="ALPHA_EQUIV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALPHA_EQUIV</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ALPHA_EQUIV</pre>
<div class="block">Quantifiers &ndash; Alpha equivalence
 
 \[
 
   \inferruleSC{-\mid F, (y_1 \ldots y_n), (z_1,\dots, z_n)}
   {F = F\{y_1\mapsto z_1,\dots,y_n\mapsto z_n\}}
   {if $y_1,\dots,y_n, z_1,\dots,z_n$ are unique bound variables}
 \]
 Notice that this rule is correct only when \(z_1,\dots,z_n\) are not
 contained in \(FV(F) \setminus \{ y_1,\dots, y_n \}\), where
 \(FV(\varphi)\) are the free variables of \(\varphi\). The internal
 quantifiers proof checker does not currently check that this is the case.</div>
</li>
</ul>
<a id="SETS_SINGLETON_INJ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SETS_SINGLETON_INJ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SETS_SINGLETON_INJ</pre>
<div class="block">Sets &ndash; Singleton injectivity
 
 \[
 
   \inferrule{\mathit{set.singleton}(t) = \mathit{set.singleton}(s)\mid -}{t=s}
 \]</div>
</li>
</ul>
<a id="SETS_EXT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SETS_EXT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> SETS_EXT</pre>
<div class="block">Sets &ndash; Sets extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{set.member}(k,a)\neq\mathit{set.member}(k,b)}
 \]
 where \(k\) is the \(\texttt{SETS_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</li>
</ul>
<a id="CONCAT_EQ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_EQ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_EQ</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation equality
 
 \[
 
   \inferrule{(t_1\cdot\ldots \cdot t_n \cdot t) = (t_1 \cdot\ldots
   \cdot t_n\cdot s)\mid b}{t = s}
 \]
 where \(\cdot\) stands for string concatenation and \(b\) indicates
 if the direction is reversed.
 
 Notice that \(t\) or \(s\) may be empty, in which case they are
 implicit in the concatenation above. For example, if the premise is
 \(x\cdot z = x\), then this rule, with argument \(\bot\), concludes
 \(z = \epsilon\).
 
 Also note that constants are split, such that for \((\mathsf{'abc'}
 \cdot x) = (\mathsf{'a'} \cdot y)\), this rule, with argument \(\bot\),
 concludes \((\mathsf{'bc'} \cdot x) = y\).  This splitting is done only
 for constants such that <code>Word.splitConstant</code> returns non-null.</div>
</li>
</ul>
<a id="CONCAT_UNIFY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_UNIFY</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_UNIFY</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation unification
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\, \mathit{len}(t_1) =
   \mathit{len}(s_1)\mid \bot}{t_1 = s_1}
 \]
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\, \mathit{len}(t_2) =
   \mathit{len}(s_2)\mid \top}{t_2 = s_2}
 \]</div>
</li>
</ul>
<a id="CONCAT_CONFLICT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_CONFLICT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_CONFLICT</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation conflict
 
 \[
 
   \inferrule{(c_1\cdot t) = (c_2 \cdot s)\mid b}{\bot}
 \]
 where \(b\) indicates if the direction is reversed, \(c_1,\,c_2\)
 are constants such that \(\texttt{Word::splitConstant}(c_1,c_2,
 \mathit{index},b)\) is null, in other words, neither is a prefix of the
 other. Note it may be the case that one side of the equality denotes the
 empty string.
 
 This rule is used exclusively for strings.</div>
</li>
</ul>
<a id="CONCAT_CONFLICT_DEQ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_CONFLICT_DEQ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_CONFLICT_DEQ</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation conflict for disequal characters
 
 \[
 
   \inferrule{(t_1\cdot t) = (s_1 \cdot s), t_1 \neq s_1 \mid b}{\bot}
 \]
 where \(t_1\) and \(s_1\) are constants of length one, or otherwise one side
 of the equality is the empty sequence and \(t_1\) or \(s_1\) corresponding to
 that side is the empty sequence.
 
 This rule is used exclusively for sequences.</div>
</li>
</ul>
<a id="CONCAT_SPLIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_SPLIT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_SPLIT</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split
 
 \[
 
   \inferruleSC{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_1) \neq \mathit{len}(s_1)\mid b}{((t_1 = s_1\cdot r)
   \vee (s_1 = t_1\cdot r)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}{if $b=\bot$}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\)
 and \(\epsilon\) is the empty string (or sequence).
 
 \[
 
   \inferruleSC{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_2) \neq \mathit{len}(s_2)\mid b}{((t_2 = r \cdot s_2)
   \vee (s_2 = r \cdot t_2)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}{if $b=\top$}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_2) &gt;= \mathit{len}(s_2),
 \mathit{pre}(t_2,\mathit{len}(t_2) - \mathit{len}(s_2)),
 \mathit{pre}(s_2,\mathit{len}(s_2) - \mathit{len}(t_2)))\)
 and \(\epsilon\) is the empty string (or sequence).
 
 Above, \(\mathit{suf}(x,n)\) is shorthand for
 \(\mathit{substr}(x,n, \mathit{len}(x) - n)\) and
 \(\mathit{pre}(x,n)\) is shorthand for \(\mathit{substr}(x,0,n)\).</div>
</li>
</ul>
<a id="CONCAT_CSPLIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_CSPLIT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_CSPLIT</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split for constants
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (c \cdot s_2),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = c\cdot r)}
 \]
 where \(r\) is the purification skolem for \(\mathit{suf}(t_1,1)\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot c),\,
   \mathit{len}(t_2) \neq 0\mid \top}{(t_2 = r\cdot c)}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{pre}(t_2,\mathit{len}(t_2) - 1)\).</div>
</li>
</ul>
<a id="CONCAT_LPROP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_LPROP</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_LPROP</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation length propagation
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_1) &gt; \mathit{len}(s_1)\mid \bot}{(t_1 = s_1\cdot r)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot t_2) = (s_1 \cdot s_2),\,
   \mathit{len}(t_2) &gt; \mathit{len}(s_2)\mid \top}{(t_2 = r \cdot s_2)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_2) &gt;= \mathit{len}(s_2),
 \mathit{pre}(t_2,\mathit{len}(t_2) - \mathit{len}(s_2)),
 \mathit{pre}(s_2,\mathit{len}(s_2) - \mathit{len}(t_2)))\)</div>
</li>
</ul>
<a id="CONCAT_CPROP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONCAT_CPROP</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> CONCAT_CPROP</pre>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation constant propagation
 
 \[
 
   \inferrule{(t_1\cdot w_1\cdot t_2) = (w_2 \cdot s),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = t_3\cdot r)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{pre}(w_2,p)\), \(p\) is
 \(\texttt{Word::overlap}(\mathit{suf}(w_2,1), w_1)\), and \(r\) is
 the purification skolem for
 \(\mathit{suf}(t_1,\mathit{len}(w_3))\).  Note that
 \(\mathit{suf}(w_2,p)\) is the largest suffix of
 \(\mathit{suf}(w_2,1)\) that can contain a prefix of \(w_1\); since
 \(t_1\) is non-empty, \(w_3\) must therefore be contained in
 \(t_1\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot w_1\cdot t_2) = (s \cdot w_2),\,
   \mathit{len}(t_2) \neq 0\mid \top}{(t_2 = r\cdot t_3)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{substr}(w_2, \mathit{len}(w_2) - p, p)\), \(p\) is
 \(\texttt{Word::roverlap}(\mathit{pre}(w_2, \mathit{len}(w_2) - 1),
 w_1)\), and \(r\) is the purification skolem for
 \(\mathit{pre}(t_2,\mathit{len}(t_2) - \mathit{len}(w_3))\).  Note that
 \(\mathit{pre}(w_2, \mathit{len}(w_2) - p)\) is the largest prefix of
 \(\mathit{pre}(w_2, \mathit{len}(w_2) - 1)\) that can contain a suffix
 of \(w_1\); since \(t_2\) is non-empty, \(w_3\) must therefore
 be contained in \(t_2\).</div>
</li>
</ul>
<a id="STRING_DECOMPOSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_DECOMPOSE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_DECOMPOSE</pre>
<div class="block">Strings &ndash; Core rules &ndash; String decomposition
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \bot}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_1) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\)
 and \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).
 Or alternatively for the reverse:
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \top}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_2) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\) and
 \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).</div>
</li>
</ul>
<a id="STRING_LENGTH_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_LENGTH_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_LENGTH_POS</pre>
<div class="block">Strings &ndash; Core rules &ndash; Length positive
 
 \[
 
   \inferrule{-\mid t}{(\mathit{len}(t) = 0\wedge t= \epsilon)\vee \mathit{len}(t)
   &gt; 0}
 \]</div>
</li>
</ul>
<a id="STRING_LENGTH_NON_EMPTY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_LENGTH_NON_EMPTY</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_LENGTH_NON_EMPTY</pre>
<div class="block">Strings &ndash; Core rules &ndash; Length non-empty
 
 \[
 
   \inferrule{t\neq \epsilon\mid -}{\mathit{len}(t) \neq 0}
 \]</div>
</li>
</ul>
<a id="STRING_REDUCTION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_REDUCTION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_REDUCTION</pre>
<div class="block">Strings &ndash; Extended functions &ndash; Reduction
 
 \[
 
   \inferrule{-\mid t}{R\wedge t = w}
 \]
 where \(w\) is \(\texttt{StringsPreprocess::reduce}(t, R,
 \dots)\). For details, see
 :cvc5src:`theory/strings/theory_strings_preprocess.h`.
 In other words, \(R\) is the reduction predicate for extended
 term \(t\), and \(w\) is the purification skolem for \(t\).
 
 Notice that the free variables of \(R\) are \(w\) and the free
 variables of \(t\).</div>
</li>
</ul>
<a id="STRING_EAGER_REDUCTION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_EAGER_REDUCTION</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_EAGER_REDUCTION</pre>
<div class="block">Strings &ndash; Extended functions &ndash; Eager reduction
 
 \[
 
   \inferrule{-\mid t}{R}
 \]
 where \(R\) is \(\texttt{TermRegistry::eagerReduce}(t)\).
 For details, see :cvc5src:`theory/strings/term_registry.h`.</div>
</li>
</ul>
<a id="RE_INTER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RE_INTER</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> RE_INTER</pre>
<div class="block">Strings &ndash; Regular expressions &ndash; Intersection
 
 \[
 
   \inferrule{t\in R_1,\,t\in R_2\mid -}{t\in \mathit{re.inter}(R_1,R_2)}
 \]</div>
</li>
</ul>
<a id="RE_UNFOLD_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RE_UNFOLD_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> RE_UNFOLD_POS</pre>
<div class="block">Strings &ndash; Regular expressions &ndash; Positive Unfold
 
 \[
 
   \inferrule{t\in R\mid -}{F}
 \]
 where \(F\) corresponds to the one-step unfolding of the premise.
 This is implemented by \(\texttt{RegExpOpr::reduceRegExpPos}(t\in R)\).</div>
</li>
</ul>
<a id="RE_UNFOLD_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RE_UNFOLD_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> RE_UNFOLD_NEG</pre>
<div class="block">Strings &ndash; Regular expressions &ndash; Negative Unfold
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{*}(R) \mid -}{t \neq \ \epsilon \ \wedge \forall L. L \leq 0 \vee \mathit{str.len}(t) &lt; L \vee \mathit{pre}(t, L) \not \in R \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{*}(R)}
 \]
 Or alternatively for regular expression concatenation:
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{++}(R_1, \ldots, R_n)\mid -}{\forall L. L &lt; 0 \vee \mathit{str.len}(t) &lt; L \vee \mathit{pre}(t, L) \not \in R_1 \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{++}(R_2, \ldots, R_n)}
 \]
 Note that in either case the varaible \(L\) has type \(Int\) and
 name `"@var.str_index"`.</div>
</li>
</ul>
<a id="RE_UNFOLD_NEG_CONCAT_FIXED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RE_UNFOLD_NEG_CONCAT_FIXED</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> RE_UNFOLD_NEG_CONCAT_FIXED</pre>
<div class="block">Strings &ndash; Regular expressions &ndash; Unfold negative concatenation, fixed
 
 .. math.
 
   \inferrule{t\not\in \mathit{re}.\text{re.++}(r_1, \ldots, r_n) \mid \bot}{
  \mathit{pre}(t, L) \not \in r_1 \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{re.++}(r_2, \ldots, r_n)}
 
 where \(r_1\) has fixed length \(L\).
 
 or alternatively for the reverse:
 
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{re.++}(r_1, \ldots, r_n) \mid \top}{
   \mathit{suf}(t, str.len(t) - L) \not \in r_n \vee
   \mathit{pre}(t, str.len(t) - L) \not \in \mathit{re}.\text{re.++}(r_1, \ldots, r_{n-1})}
 \]
 where \(r_n\) has fixed length \(L\).</div>
</li>
</ul>
<a id="STRING_CODE_INJ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_CODE_INJ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_CODE_INJ</pre>
<div class="block">Strings &ndash; Code points
 
 \[
 
   \inferrule{-\mid t,s}{\mathit{to\_code}(t) = -1 \vee \mathit{to\_code}(t) \neq
   \mathit{to\_code}(s) \vee t = s}
 \]</div>
</li>
</ul>
<a id="STRING_SEQ_UNIT_INJ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>STRING_SEQ_UNIT_INJ</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> STRING_SEQ_UNIT_INJ</pre>
<div class="block">Strings &ndash; Sequence unit
 
 \[
 
   \inferrule{\mathit{unit}(x) = \mathit{unit}(y)\mid -}{x = y}
 \]
 Also applies to the case where \(\mathit{unit}(y)\) is a constant
 sequence of length one.</div>
</li>
</ul>
<a id="MACRO_STRING_INFERENCE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_STRING_INFERENCE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_STRING_INFERENCE</pre>
<div class="block">Strings &ndash; (Macro) String inference
 
 \[
 
   \inferrule{?\mid F,\mathit{id},\mathit{isRev},\mathit{exp}}{F}
 \]
 used to bookkeep an inference that has not yet been converted via
 \(\texttt{strings::InferProofCons::convert}\).</div>
</li>
</ul>
<a id="MACRO_RE_ELIM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_RE_ELIM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_RE_ELIM</pre>
<div class="block">Strings &ndash; Regular expressions &ndash; Macro elimination
 
 \[
 
   \inferrule{-\mid F,b}{F = F'}
 \]
 where \(F'\) is the result of eliminating regular expressions from
 \(F\) using the routine
 \(\texttt{strings::RegExpElimination::eliminate}(F, b)\).
 Here, \(b\) is a Boolean indicating whether we are using aggressive
 eliminations. Notice this rule concludes \(F = F\) if no eliminations
 are performed for \(F\).
 
 We do not currently support elaboration of this macro.</div>
</li>
</ul>
<a id="MACRO_ARITH_SCALE_SUM_UB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MACRO_ARITH_SCALE_SUM_UB</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> MACRO_ARITH_SCALE_SUM_UB</pre>
<div class="block">Arithmetic &ndash; Adding inequalities
 
 An arithmetic literal is a term of the form \(p \diamond c\) where
 \(\diamond \in \{ &lt;, \leq, =, \geq, &gt; \}\), \(p\) a
 polynomial and \(c\) a rational constant.
 
 \[
   \inferrule{l_1 \dots l_n \mid k_1 \dots k_n}{t_1 \diamond t_2}
 \]
 where \(k_i \in \mathbb{R}, k_i \neq 0\), \(\diamond\) is the
 fusion of the \(\diamond_i\) (flipping each if its \(k_i\) is
 negative) such that \(\diamond_i \in \{ &lt;, \leq \}\) (this implies that
 lower bounds have negative \(k_i\) and upper bounds have positive
 \(k_i\)), \(t_1\) is the sum of the scaled polynomials and
 \(t_2\) is the sum of the scaled constants:
 
 \[
   t_1 \colon= k_1 \cdot p_1 + \cdots + k_n \cdot p_n
 
   t_2 \colon= k_1 \cdot c_1 + \cdots + k_n \cdot c_n
 \]</div>
</li>
</ul>
<a id="ARITH_SUM_UB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_SUM_UB</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_SUM_UB</pre>
<div class="block">Arithmetic &ndash; Sum upper bounds
 
 \[
   \inferrule{P_1 \dots P_n \mid -}{L \diamond R}
 \]
 where \(P_i\) has the form \(L_i \diamond_i R_i\) and
 \(\diamond_i \in \{&lt;, \leq, =\}\). Furthermore \(\diamond = &lt;\) if
 \(\diamond_i = &lt;\) for any \(i\) and \(\diamond = \leq\)
 otherwise, \(L = L_1 + \cdots + L_n\) and \(R = R_1 + \cdots + R_n\).</div>
</li>
</ul>
<a id="INT_TIGHT_UB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INT_TIGHT_UB</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> INT_TIGHT_UB</pre>
<div class="block">Arithmetic &ndash; Tighten strict integer upper bounds
 
 \[
   \inferrule{i &lt; c \mid -}{i \leq \lfloor c \rfloor}
 \]
 where \(i\) has integer type.</div>
</li>
</ul>
<a id="INT_TIGHT_LB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INT_TIGHT_LB</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> INT_TIGHT_LB</pre>
<div class="block">Arithmetic &ndash; Tighten strict integer lower bounds
 
 \[
   \inferrule{i &gt; c \mid -}{i \geq \lceil c \rceil}
 \]
 where \(i\) has integer type.</div>
</li>
</ul>
<a id="ARITH_TRICHOTOMY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRICHOTOMY</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRICHOTOMY</pre>
<div class="block">Arithmetic &ndash; Trichotomy of the reals
 
 \[
   \inferrule{A, B \mid -}{C}
 \]
 where \(\neg A, \neg B, C\) are \(x &lt; c, x = c, x &gt; c\) in some order.
 Note that \(\neg\) here denotes arithmetic negation, i.e., flipping \(\geq\) to \(&lt;\) etc.</div>
</li>
</ul>
<a id="ARITH_OP_ELIM_AXIOM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_OP_ELIM_AXIOM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_OP_ELIM_AXIOM</pre>
<div class="block">Arithmetic &ndash; Operator elimination
 
 \[
   \inferrule{- \mid t}{\texttt{arith::OperatorElim::getAxiomFor(t)}}
 \]</div>
</li>
</ul>
<a id="ARITH_POLY_NORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_POLY_NORM</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_POLY_NORM</pre>
<div class="block">Arithmetic &ndash; Polynomial normalization
 
 \[
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\). This
 method normalizes polynomials \(s\) and \(t\) over arithmetic or
 bitvectors.</div>
</li>
</ul>
<a id="ARITH_POLY_NORM_REL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_POLY_NORM_REL</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_POLY_NORM_REL</pre>
<div class="block">Arithmetic &ndash; Polynomial normalization for relations
 
 .. math.
  \inferrule{c_x \cdot (x_1 - x_2) = c_y \cdot (y_1 - y_2) \mid \diamond}
            {(x_1 \diamond x_2) = (y_1 \diamond y_2)}
 
 where \(\diamond \in \{&lt;, \leq, =, \geq, &gt;\}\) for arithmetic and
 \(\diamond \in \{=\}\) for bitvectors. \(c_x\) and :math:c_y` are
 scaling factors. For \(&lt;, \leq, \geq, &gt;\), the scaling factors have the
 same sign. For bitvectors, they are set to \(1\).</div>
</li>
</ul>
<a id="ARITH_MULT_SIGN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_MULT_SIGN</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_MULT_SIGN</pre>
<div class="block">Arithmetic &ndash; Sign inference
 
 \[
   \inferrule{- \mid f_1 \dots f_k, m}{(f_1 \land \dots \land f_k) \rightarrow m \diamond 0}
 \]
 where \(f_1 \dots f_k\) are variables compared to zero (less, greater
 or not equal), \(m\) is a monomial from these variables and
 \(\diamond\) is the comparison (less or equal) that results from the
 signs of the variables. All variables with even exponent in \(m\)
 should be given as not equal to zero while all variables with odd exponent
 in \(m\) should be given as less or greater than zero.</div>
</li>
</ul>
<a id="ARITH_MULT_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_MULT_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_MULT_POS</pre>
<div class="block">Arithmetic &ndash; Multiplication with positive factor
 
 \[
   \inferrule{- \mid m, l \diamond r}{(m &gt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond m \cdot r}
 \]
 where \(\diamond\) is a relation symbol.</div>
</li>
</ul>
<a id="ARITH_MULT_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_MULT_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_MULT_NEG</pre>
<div class="block">Arithmetic &ndash; Multiplication with negative factor
 
 \[
   \inferrule{- \mid m, l \diamond r}{(m &lt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond_{inv} m \cdot r}
 \]
 where \(\diamond\) is a relation symbol and \(\diamond_{inv}\) the
 inverted relation symbol.</div>
</li>
</ul>
<a id="ARITH_MULT_TANGENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_MULT_TANGENT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_MULT_TANGENT</pre>
<div class="block">Arithmetic &ndash; Multiplication tangent plane
 
 \[
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \leq tplane) \leftrightarrow ((x \leq a \land y \geq b) \lor (x \geq a \land y \leq b))}{if $\sigma = -1$}
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \geq tplane) \leftrightarrow ((x \leq a \land y \leq b) \lor (x \geq a \land y \geq b))}{if $\sigma = 1$}
 \]
 where \(x,y\) are real terms (variables or extended terms),
 \(t = x \cdot y\), \(a,b\) are real
 constants, \(\sigma \in \{ 1, -1\}\) and \(tplane := b \cdot x + a \cdot y - a \cdot b\) is the tangent plane of \(x \cdot y\) at \((a,b)\).</div>
</li>
</ul>
<a id="ARITH_TRANS_PI">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_PI</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_PI</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Assert bounds on Pi
 
 \[
   \inferrule{- \mid l, u}{\texttt{real.pi} \geq l \land \texttt{real.pi}
   \leq u}
 \]
 where \(l,u\) are valid lower and upper bounds on \(\pi\).</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_NEG</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at negative values
 
 \[
   \inferrule{- \mid t}{(t &lt; 0) \leftrightarrow (\exp(t) &lt; 1)}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_POSITIVITY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_POSITIVITY</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_POSITIVITY</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is always positive
 
 \[
   \inferrule{- \mid t}{\exp(t) &gt; 0}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_SUPER_LIN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_SUPER_LIN</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_SUPER_LIN</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp grows super-linearly for positive
 values
 
 \[
   \inferrule{- \mid t}{t \leq 0 \lor \exp(t) &gt; t+1}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_ZERO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_ZERO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_ZERO</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at zero
 
 \[
   \inferrule{- \mid t}{(t=0) \leftrightarrow (\exp(t) = 1)}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_APPROX_ABOVE_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_APPROX_ABOVE_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_APPROX_ABOVE_NEG</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for
 negative values
 
 \[
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\). Let \(p\) be
 the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the exponential function. \(\texttt{secant}(\exp, l, u, t)\)
 denotes the secant of \(p\) from \((l, \exp(l))\) to \((u,
 \exp(u))\) evaluated at \(t\), calculated as follows:
 
 \[
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\exp(t\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_APPROX_ABOVE_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_APPROX_ABOVE_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_APPROX_ABOVE_POS</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for
 positive values
 
 \[
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant-pos}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\). Let \(p^*\) be
 a modification of the \(d\)'th taylor polynomial at zero (also called
 the Maclaurin series) of the exponential function as follows where
 \(p(d-1)\) is the regular Maclaurin series of degree \(d-1\):
 
 \[
   p^* := p(d-1) \cdot \frac{1 + t^n}{n!}
 \]
 \(\texttt{secant-pos}(\exp, l, u, t)\) denotes the secant of \(p\)
 from \((l, \exp(l))\) to \((u, \exp(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\exp(t\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</li>
</ul>
<a id="ARITH_TRANS_EXP_APPROX_BELOW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_EXP_APPROX_BELOW</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_EXP_APPROX_BELOW</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from below
 
 \[
   \inferrule{- \mid d,c,t}{t \geq c \rightarrow exp(t) \geq \texttt{maclaurin}(\exp, d, c)}
 \]
 where \(d\) is an odd positive number, \(t\) an arithmetic term and
 \(\texttt{maclaurin}(\exp, d, c)\) is the \(d\)'th taylor
 polynomial at zero (also called the Maclaurin series) of the exponential
 function evaluated at \(c\). The Maclaurin series for the exponential
 function is the following:
 
 \[
   \exp(x) = \sum_{n=0}^{\infty} \frac{x^n}{n!}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_BOUNDS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_BOUNDS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_BOUNDS</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is always between -1 and 1
 
 \[
   \inferrule{- \mid t}{\sin(t) \leq 1 \land \sin(t) \geq -1}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_SHIFT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_SHIFT</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_SHIFT</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is shifted to -pi...pi
 
 \[
   \inferrule{- \mid x}{-\pi \leq y \leq \pi \land \sin(y) = \sin(x)
   \land (\ite{-\pi \leq x \leq \pi}{x = y}{x = y + 2 \pi s})}
 \]
 where \(x\) is the argument to sine, \(y\) is a new real skolem
 that is \(x\) shifted into \(-\pi \dots \pi\) and \(s\) is a
 new integer skolem that is the number of phases \(y\) is shifted.
 In particular, \(y\) is the
 TRANSCENDENTAL_PURIFY_ARG &lt;cvc5.<a href="SkolemId.html#TRANSCENDENTAL_PURIFY_ARG"><code>SkolemId.TRANSCENDENTAL_PURIFY_ARG</code></a>&gt;
 skolem for \(\sin(x)\) and \(s\) is the
 TRANSCENDENTAL_SINE_PHASE_SHIFT &lt;cvc5.<a href="SkolemId.html#TRANSCENDENTAL_SINE_PHASE_SHIFT"><code>SkolemId.TRANSCENDENTAL_SINE_PHASE_SHIFT</code></a>&gt;
 skolem for \(x\).</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_SYMMETRY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_SYMMETRY</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_SYMMETRY</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is symmetric with respect to
 negation of the argument
 
 \[
   \inferrule{- \mid t}{\sin(t) - \sin(-t) = 0}
 \]</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_TANGENT_ZERO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_TANGENT_ZERO</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_TANGENT_ZERO</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangent at zero
 
 .. math.
   \inferrule{- \mid t}{(t &gt; 0 \rightarrow \sin(t) &lt; t) \land (t &lt; 0
   \rightarrow \sin(t) &gt; t)}</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_TANGENT_PI">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_TANGENT_PI</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_TANGENT_PI</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangents at -pi
 and pi
 
 .. math.
   \inferrule{- \mid t}{(t &gt; -\pi \rightarrow \sin(t) &gt; -\pi - t) \land (t &lt;
   \pi \rightarrow \sin(t) &lt; \pi - t)}</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_APPROX_ABOVE_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_APPROX_ABOVE_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_APPROX_ABOVE_NEG</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for
 negative values
 
 \[
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\). Let \(p\) be the \(d\)'th taylor polynomial at
 zero (also called the Maclaurin series) of the sine function.
 \(\texttt{secant}(\sin, l, u, t)\) denotes the secant of \(p\) from
 \((l, \sin(l))\) to \((u, \sin(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\sin(t)\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_APPROX_ABOVE_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_APPROX_ABOVE_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_APPROX_ABOVE_POS</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for
 positive values
 
 \[
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{upper}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)). Let \(p\)
 be the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the sine function. \(\texttt{upper}(\sin, c)\) denotes the
 upper bound on \(\sin(c)\) given by \(p\) and \(lb,up\) such
 that \(\sin(t)\) is the maximum of the sine function on
 \((lb,ub)\).</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_APPROX_BELOW_NEG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_APPROX_BELOW_NEG</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_APPROX_BELOW_NEG</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for
 negative values
 
 \[
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{lower}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)). Let \(p\)
 be the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the sine function. \(\texttt{lower}(\sin, c)\) denotes the
 lower bound on \(\sin(c)\) given by \(p\) and \(lb,up\) such
 that \(\sin(t)\) is the minimum of the sine function on
 \((lb,ub)\).</div>
</li>
</ul>
<a id="ARITH_TRANS_SINE_APPROX_BELOW_POS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ARITH_TRANS_SINE_APPROX_BELOW_POS</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ARITH_TRANS_SINE_APPROX_BELOW_POS</pre>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for
 positive values
 
 \[
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\). Let \(p\) be the \(d\)'th taylor polynomial at
 zero (also called the Maclaurin series) of the sine function.
 \(\texttt{secant}(\sin, l, u, t)\) denotes the secant of \(p\) from
 \((l, \sin(l))\) to \((u, \sin(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\sin(t)\) is above the secant of \(p\) from \(l\) to
 \(u\).</div>
</li>
</ul>
<a id="LFSC_RULE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LFSC_RULE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> LFSC_RULE</pre>
<div class="block">External &ndash; LFSC
 
 Place holder for LFSC rules.
 
 \[
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external LFSC calculus.</div>
</li>
</ul>
<a id="ALETHE_RULE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALETHE_RULE</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> ALETHE_RULE</pre>
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.
 
 \[
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, Q', A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external Alethe calculus,
 and that \(Q'\) be the representation of Q to be printed by the Alethe
 printer.</div>
</li>
</ul>
<a id="UNKNOWN">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>UNKNOWN</h4>
<pre>public static final&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a> UNKNOWN</pre>
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.
 
 \[
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, Q', A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external Alethe calculus,
 and that \(Q'\) be the representation of Q to be printed by the Alethe
 printer.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="values()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>values</h4>
<pre class="methodSignature">public static&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>[]&nbsp;values()</pre>
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared. This method may be used to iterate
over the constants as follows:
<pre>
for (ProofRule c : ProofRule.values())
&nbsp;   System.out.println(c);
</pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array containing the constants of this enum type, in the order they are declared</dd>
</dl>
</li>
</ul>
<a id="valueOf(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>valueOf</h4>
<pre class="methodSignature">public static&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>&nbsp;valueOf&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">Returns the enum constant of this type with the specified name.
The string must match <i>exactly</i> an identifier used to declare an
enum constant in this type.  (Extraneous whitespace characters are 
not permitted.)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - the name of the enum constant to be returned.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the enum constant with the specified name</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if this enum type has no constant with the specified name</dd>
<dd><code>java.lang.NullPointerException</code> - if the argument is null</dd>
</dl>
</li>
</ul>
<a id="fromInt(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromInt</h4>
<pre class="methodSignature">public static&nbsp;<a href="ProofRule.html" title="enum in io.github.cvc5">ProofRule</a>&nbsp;fromInt&#8203;(int&nbsp;value)
                         throws <a href="CVC5ApiException.html" title="class in io.github.cvc5">CVC5ApiException</a></pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="CVC5ApiException.html" title="class in io.github.cvc5">CVC5ApiException</a></code></dd>
</dl>
</li>
</ul>
<a id="getValue()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getValue</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getValue()</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"> <script> window.MathJax = { 'loader': { 'load': ['[tex]/ams','[tex]/bussproofs'], }, 'tex': { 'packages': { '[+]': ['ams','bussproofs'], }, 'macros': { 'xor': '\\mathbin{xor}', 'ite': ['#1~\\mathbin{?}~#2~\\mathbin{:}~#3',3], 'inferrule': ['\\begin{prooftree}\\AxiomC{$#1$}\\UnaryInfC{$#2$}\\end{prooftree}',2], 'inferruleSC': ['\\begin{prooftree}\\AxiomC{$#1$}\\RightLabel{~#3}\\UnaryInfC{$#2$}\\end{prooftree}',3], } } } </script> <script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'> </script> </div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum.constant.summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum.constant.detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
